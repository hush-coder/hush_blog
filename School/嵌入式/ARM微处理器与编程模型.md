# 微处理器相关概念

## 计算机体系结构

### 冯诺伊曼结构

***核心思想***
- 将程序（指令序列的集合）和数据存放在**同一**存储器的不同地址；
- **顺序**执行指令
- 执行过程：取指令（**or**数据）-> 分析指令 -> 执行指令。

### 哈佛结构

***核心思想***
- 将程序（指令序列的集合）和数据存放在**不同**存储器；
- **并行**执行指令
- 执行过程：取指令（**and**数据）-> 分析指令 -> 执行指令。

> 哈佛结构适用与强实时性的应用。

## 计算机指令系统

指令集指计算机所能执行的全部指令（功能）的集合。从系统结构角度看，它实现了软件和硬件的交互联系，是表征计算机性能的重要因素。

### CISC：复杂指令集计算机

**设计目标**：用最少的机器语言指令来完成所需的计算任务。

*CPU包括丰富的单元电路，功能强面积大价格高功耗大。*

### RISC：精简指令集计算机

**设计目标**：借助一些可以在单个CPU周期完成的指令，以降低CPU的复杂度，将程序的复杂性交给编译器。

**Load-Store结构**：CPU只处理寄存器中的数据，使用Load/Store指令来完成数据在寄存器和外部存储器之间的传送。

CPU硬件结构设计变得简单、面积小功耗低。

### 主流嵌入式微处理器架构

***MIPS***

MIPS 最初指的是"Microprocessor without Interlocked Pipeline Stages"，但现在更常被称为"Microprocessor without Interlocked Pipeline Stages"或简称为MIPS架构。

**主要特点**

- **RISC架构**：MIPS是一种精简指令集计算机架构，指令集相对简单，指令长度固定（32位）
- **流水线设计**：MIPS处理器采用流水线技术，可以在一个时钟周期内执行多条指令的不同阶段
- **寄存器设计**：通常有32个通用寄存器，每个32位宽
- **指令格式**：主要有三种指令格式：
    - R型指令（寄存器型）
    - I型指令（立即数型）
    - J型指令（跳转型）

***RISC-V***

### 寻址方式

***CISC：寻址方式复杂***

```
开始 → IF(指令取指) → ID(指令译码) → [核心处理单元] → 退出
```

**核心处理单元内部结构**：
- ALU (算术逻辑单元)
- MEM (内存)
- REG (寄存器)

**微操作通道（Micro-operation Channel）**

CISC架构中，这三个组件之间形成复杂的多向互联网络：
1. ALU ↔ MEM：双向通信
    - ALU可以直接从内存读取数据
    - ALU可以直接向内存写入数据
    - 支持复杂的寻址计算
2. ALU ↔ REG：双向通信
    - 寄存器可以直接参与ALU运算
    - ALU结果可以直接写回寄存器
3. MEM ↔ REG：双向通信
    - 内存和寄存器之间可以直接交换数据
    - 支持多种寻址模式

***RISC：Load/Store结构***

```
开始 → IF(指令取指) → ID(指令译码) → [核心处理单元] → 退出
```

**核心处理单元内部结构**：
- REG (寄存器) - 数据处理的中心
- ALU (算术逻辑单元) - 只处理寄存器数据
- MEM (内存) - 独立的数据存储

**单通数据通道（Single-pass Data Channel）**

1. REG → ALU：单向数据流
    - 所有运算操作数必须先从寄存器加载
    - ALU只处理寄存器中的数据
2. ALU → REG：单向数据流
    - 运算结果直接写回寄存器
    - 保持数据在寄存器中
3. MEM → REG：Load操作
    - 只有Load指令可以从内存读取数据到寄存器
    - 数据必须先加载到寄存器才能使用
4. REG → MEM：Store操作
    - 只有Store指令可以将寄存器数据写入内存
    - 所有内存写入都必须通过寄存器

## CISC与RISC架构对比

| 类别       | CISC (复杂指令集计算机)                                                              | RISC (精简指令集计算机)                                  |
| :--------- | :----------------------------------------------------------------------------------- | :------------------------------------------------------- |
| **指令系统** | 指令数量很多                                                                         | 较少，通常少于100                                        |
| **执行时间** | 有些指令执行时间很长，如整块的存储器内容拷贝；或将多个寄存器的内容拷贝到存储器       | 没有较长执行时间的指令                                   |
| **编码长度** | 编码长度可变，1-15字节                                                               | 编码长度固定，通常为4个字节                              |
| **寻址方式** | 寻址方式多样                                                                         | 简单寻址                                                 |
| **操作**   | 可以对存储器和寄存器进行算术和逻辑操作                                               | 只能对寄存器进行算术和逻辑操作，Load/Store体系结构       |
| **编译**   | 难以用优化编译器生成高效的目标代码程序                                               | 采用优化编译技术，生成高效的目标代码程序                 |

> **注意：** 哈佛结构和冯诺依曼结构主要是指计算机的存储器结构，与指令系统没有严格的对应关系。

## 流水线技术

流水线（Pipeline）技术：几条指令可以并行执行。

- 冯诺依曼结构--不区分数据和程序存储器
- 为了提高CPU的运行效率

# ARM微处理器概述

## ARM体系结构版本的命名规则

$$ 
| \ ARM  \ \ \ V_n \ | \ variants \ | \ X \ (variants) \ |
$$

- $V_n$：对应的指令集的版本号。n = 1~8.
- $variants$：支持的变种类型。
- $X \ (variants)$：不支持的变种类型。

# ARM微处理器结构

***ARM  CPU（内核） + 外围部件（设备）= ARM芯片***

## ARM内核结构

包含ALU、桶形移位器、乘法器、浮点部件（可选）、指令译码及控制逻辑、指令流水线、数据/地址寄存器、状态寄存器、总线等

***微处理器 = 运算部件 + 控制部件 + 寄存器组 + 总线***

## ARM7TDMI微处理器

1. ARM通用32位微处理器，ARMv4T版架构

2. 采用**冯诺依曼结构**：
    - 指令和数据共用一条32位总线
    - 使用装载、存储、交换指令访问存储器
    - 数据宽度：8位（字节）、16位（半字）、32位（字）

3. **三级流水线**：取指令 -> 指令译码 -> 执行指令
    - 可提供0.9MIPS/MHz的指令执行速度

4. **性能优异**
    - 高的指令吞吐量。
    - 出色的实时中断响应。
    - 体积小、性价比高的处理器宏单元。

5. **算术逻辑单元**
    - 实现算术运算和逻辑运算

6. **寄存器组**
    - 由31个32位通用寄存器（R0~R30）和6个32位状态寄存器组成，用于保存处理器状态和工作中的数据

7. **对外端口**
    - 2个读端口：用于读2个源操作数（可访问任意寄存器）
    - 1个写端口：用于写入目的操作数（可访问任意寄存器）
    - 1个附加读端口（用于访问程序计数器R15（PC））
    - 1个附加写端口（用于访问程序计数器R15（PC））

8. 桶形移位器
    - 主要用于完成指令中第2个操作数移位

9. 地址寄存器和地址增量器
    - 选择和保存存储器的地址，并在需要时通过地址增量器生成顺序地址

10. 数据寄存器
    - 对传送到存储器或从存储器取回的数据进行暂存

11. 控制器
    - 指令解（译）码
    - 相关控制逻辑
    - ......

## ARM9TDMI微处理器

1. ARM通用32位微处理器，ARMv4T版架构

2. 采用**哈佛结构**：
    - 指令和数据拥有独立的32位总线和MMU。
    - 装载、存储指令执行时间比ARM7减少约30%
    - 数据宽度：8位（字节）、16位（半字）、32位（字）

3. **五级流水线**：取指令 -> 指令译码 -> 执行指令 -> 数据存储器/数据cache访问 -> 寄存器回写
    - 可提供300MIPS/MHz的指令执行速度

4. 通过硬件实现Thumb指令解码。

# ARM微处理器运行模式

## ARM处理器模式

| 处理器模式 | 用途 |
| :--------- | :--- |
| **USR (用户模式)** | ARM处理器正常的程序执行状态 |
| **FIQ (快速中断模式)** | 用于高速数据传输或通道处理 |
| **IRQ (外部中断模式)** | 用户通用的中断处理 |
| **SVC (管理模式)** | 操作系统使用的保护模式，处理软件中断 |
| **ABT (数据访问中止模式)** | 当数据或指令预取中止时进入该模式，可用于虚拟存储器和存储器保护 |
| **UND (未定义指令模式)** | 当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真 |
| **SYS (系统模式)** | 运行具有特权的操作系统任务 |

## 用户模式与特权模式

除了用户模式之外，其余的6种成为特权模式。

### 特权模式
- 访问权限很高
- 任意切换处理器模式

### 用户模式
- 权限不是最高
- 不能直接切换到其他特权模式，但通过异常实现
- 大都数应用运行在这。

## 异常模式

除了用户和系统模式，都是异常模式

## 模式切换方法

### ARM处理器模式详细说明

| 处理器模式 | 备注 |
| :--------- | :--- |
| **USR (用户模式)** | 不能直接切换到其它模式 |
| **SYS (系统模式)** | 与用户模式类似,但具有可以直接切换到其它模式等特权 |
| **FIQ (快速中断模式)** | FIQ异常响应时进入此模式 |
| **IRQ (外部中断模式)** | IRQ异常响应时进入此模式 |
| **SVC (管理模式)** | 系统复位和软件中断响应时进入此模式 |
| **ABT (数据访问中止模式)** | 数据或指令预取中止时进入该模式 |
| **UND (未定义指令模式)** | 未定义指令异常响应时进入此模式 |

# ARM微处理器寄存器组织

Thumb寄存器组是ARM的子集

## 通用寄存器（31个）

1. 未分组寄存器（R0 ~ R7）
2. 分组寄存器（R8 ~ R14）
    - (不完全)R8~R12：使用快速中断模式，对应物理R8_fiq~R12_fiq；否则R8_usr~R12_usr
    - (完全)R13~R14：一个物理是用户与系统模式公用，其余对应五个异常模式

3. R13-堆栈指针

每种模式有自己的R13，用于异常模式的暂存。

4. R14-子程序链接寄存器

- 用于保存返回地址
- 其他情况，用作通用寄存器。

***中断嵌套***

原本运行用户模式下程序，发生IRQ中断异常跳到程序A，把某个地址存入R14_irq寄存器，然后运行完程序A之后会将该地址取出，加偏置，返回之前的程序。

可如果程序A运行过程中有一次中断异常，此时R14_irq的地址会被覆盖，出现错误

**解决方案**：使用堆栈保存R14的值，或者切换到其他处理器模式下。

5. R15-程序计数器PC

- ARM状态：bit[1:0]=00,bit[31:2]PC的值指向当前正在执行指令的地址值+8，即当前正在执行指令的下两条指令。
**原因**：ARM采用多级流水线技术

- Thumb状态：bit[0]=0，，bit[31:1]

## 状态寄存器（6个）

1. 当前程序状态寄存器CPSR：所有运行模式下都指向相同物理寄存器。

2. 备份程序状态寄存器SPSR：
    - 每种异常模式都有自己的专用物理寄存器
    - 异常发生时，保存CPSR：异常退出时用于恢复CPSR。
    - 用户模式和系统模式下无效

### 条件码标志位

ARM状态：据大多数指令有条件

Thumb状态：仅有分支指令（B指令）有条件。

| 标志位 | 含义 |
| :----- | :--- |
| **N (Negative)** | 负数标志位。当运算结果为负数时，N=1；否则N=0 |
| **Z (Zero)** | 零标志位。当运算结果为零时，Z=1；否则Z=0 |
| **C (Carry)** | 进位标志位。当运算产生进位时，C=1；否则C=0 |
| **V (Overflow)** | 溢出标志位。当运算产生溢出时，V=1；否则V=0 |
| **I (IRQ disable)** | IRQ中断禁止位。当I=1时，禁止IRQ中断；当I=0时，允许IRQ中断 |
| **F (FIQ disable)** | FIQ中断禁止位。当F=1时，禁止FIQ中断；当F=0时，允许FIQ中断 |
| **T (Thumb state)** | Thumb状态位。当T=1时，处理器处于Thumb状态；当T=0时，处理器处于ARM状态 |
| **M[4:0]** | 模式位。用于指定处理器当前运行的模式 |
| **Q** | 在ARM v5及以后版本的E系列处理器中，Q标志位表示DSP操作指令是否发生溢出。在其他版本中，Q标志位未定义 |

### 保留位

为保证可以执行，莫改变

### 控制位

***IFTM***

- 中断禁止位I、F；决定终端能都发生
- 模式位M：决定处理器的运行模式。
- 工作状态位T：反映处理器的运行状态。

## Thumb状态下的寄存器组

- 程序可以直接访问8通、堆栈（SP）、链接寄存器（LR）、程序计数器（PC）
- 条件访问CPSR
- 每个异常模式都有一组SP、LR、SPSR

## 两种状态下的关系

- 8个通用寄存器相同
- CPSR和SPSR完全相同

| Thumb状态 | ARM状态 |
| :----- | :--- |
| SR | R13 |
| LR | R14 |
| PC | R15 |

# ARM微处理器存储器格式

***V8之前版本***

- 从零地址的字节线性组合
- 寻址空间4GB
- 两种存储字数据的方法（大端、小端）

## 大端格式

字数据的高字节存储在低地址，低字节存储在高地址

```
32位数据: 0x12345678

内存地址布局 (大端格式):
┌─────────┬─────────┬─────────┬─────────┐
│ 0x1000  │ 0x1001  │ 0x1002  │ 0x1003  │
├─────────┼─────────┼─────────┼─────────┤
│   0x12  │   0x34  │   0x56  │   0x78  │
│ (高字节) │         │         │ (低字节)│
└─────────┴─────────┴─────────┴─────────┘
   ↑                           ↑
   └─── 高字节在前 (Big-Endian) ──┘
```

## 小端格式

字数据的高字节存储在高地址，低字节存储在低地址 **（较常用）**

```
32位数据: 0x12345678

内存地址布局 (小端格式):
┌─────────┬─────────┬─────────┬─────────┐
│ 0x1000  │ 0x1001  │ 0x1002  │ 0x1003  │
├─────────┼─────────┼─────────┼─────────┤
│   0x78  │   0x56  │   0x34  │   0x12  │
│ (低字节)│         │         │ (高字节)│
└─────────┴─────────┴─────────┴─────────┘
   ↑                           ↑
   └─── 低字节在前 (Little-Endian) ──┘
```

### 存储格式对比

| 格式 | 地址0x1000 | 地址0x1001 | 地址0x1002 | 地址0x1003 | 说明 |
| :--- | :--------- | :--------- | :--------- | :--------- | :--- |
| **大端** | 0x12 (高字节) | 0x34 | 0x56 | 0x78 (低字节) | 高字节在前 |
| **小端** | 0x78 (低字节) | 0x56 | 0x34 | 0x12 (高字节) | 低字节在前 |

## ARM内存管理

支持多任务的复杂嵌入式系统里面，物理存储 << 用用所需，所以会使用虚拟存储空间，即应用程序中使用虚拟地址，而访问存储器使用物理地址。
这个就叫**虚拟存储技术**。

### 存储器管理单元MMU

- 将虚拟地址转换为物理地址
- 存储器访问权限控制
- 设置虚拟存储空间的缓冲特性等。
> MMU无效时，虚拟地址将直接输出到物理地址总线。

### 分页式存储管理

- 虚拟存储空间分成一个个固定大小的**页**，把物理主存储空间也分成同样大小的**页框**。
- 通过查询存放在主存中的**页表**，来实现转换
- 由于查询代价大，所以用快表技术（TLB）
> **地址转换条目**：表示虚拟地址和物理地址对应关系的记录，也成为页表条目

### 基于TLB的地址转换过程

- 微处理器访问贮存是，现根据虚拟在TLB中查找条目，命中则直接转换。
- 若未命中，则继续在主存页表中查找，将结果添加到TLB。
- 添加时，若TLB已满，则根据算法进行淘汰。

### 两种存储空间映射单位

- 虚拟到物理的映射是以存储块为单位所进行。
- 在页表/TLB中，每个Entry记录了一个虚存的存储块的及地址与物存的一个存储块的基地址的对应关系。

$$
地址=基地址+偏移地址
$$

### ARM920T支持的存储块类型

| 地址转换条目 | 存储块类型 |
| :----- | :--- |
| 段描述符 | 段：大小为1MB的存储块 |
| 大页描述符 | 大页：大小为64kB的存储块 |
| 小页描述符 | 小页：大小为4kB的存储块 |
| 极小页描述符 | 极小页：大小为1KB的存储块 |

## ARM两级页表结构 (L1 + L2)

### 基本概念

ARM处理器采用两级页表结构进行虚拟地址到物理地址的转换：
- **L1页表 (First-level Table)**：页目录表，存储L2页表的地址
- **L2页表 (Second-level Table)**：页表，存储实际物理页的地址

### 地址划分

对于32位虚拟地址，两级页表结构将其划分为：

```
32位虚拟地址: [31:20] [19:12] [11:0]
                │       │      │
                │       │      └── 页内偏移 (12位)
                │       └────────── L2页表索引 (8位)  
                └────────────────── L1页表索引 (12位)
```

- **L1页表索引 (12位)**：指向L1页表中的条目，可索引4096个L1页表项
- **L2页表索引 (8位)**：指向L2页表中的条目，可索引256个L2页表项
- **页内偏移 (12位)**：在4KB页面内的偏移地址

### 两级页表结构图

```
虚拟地址转换过程:

虚拟地址: 0x12345678
┌─────────────────────────────────────────────────────────┐
│ L1索引  │ L2索引  │ 页内偏移 │
│ 0x123   │  0x45   │  0x678  │
└─────────────────────────────────────────────────────────┘
     │         │        │
     │         │        │
     ▼         ▼        ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│ L1页表  │ │ L2页表   │ │ 物理页  │
│         │ │         │ │         │
│[0x123]  │→│[0x45]   │→│+0x678   │→ 物理地址
│         │ │         │ │         │
└─────────┘ └─────────┘ └─────────┘
```

### L1页表 (First-level Table)

- **作用**：存储L2页表的物理地址
- **大小**：4KB，包含1024个条目
- **条目大小**：4字节
- **索引方式**：使用虚拟地址[31:20]作为索引

### L2页表 (Second-level Table)

- **作用**：存储实际物理页的地址
- **大小**：1KB，包含256个条目
- **条目大小**：4字节
- **索引方式**：使用虚拟地址[19:12]作为索引

### 页表定位的详细过程

#### 步骤1：L1页表定位

```
虚拟地址: 0x12345678
L1索引 = 虚拟地址[31:20] = 0x123

L1页表基地址 = 0x20000000 (假设)
L1页表条目地址 = L1页表基地址 + (L1索引 × 4)
                = 0x20000000 + (0x123 × 4)
                = 0x20000000 + 0x48C
                = 0x2000048C

从地址0x2000048C读取4字节 → 得到L2页表基地址
```

#### 步骤2：L2页表定位

```
虚拟地址: 0x12345678
L2索引 = 虚拟地址[19:12] = 0x45

L2页表基地址 = 0x30000000 (从L1页表条目获得)
L2页表条目地址 = L2页表基地址 + (L2索引 × 4)
                = 0x30000000 + (0x45 × 4)
                = 0x30000000 + 0x114
                = 0x30000114

从地址0x30000114读取4字节 → 得到物理页基地址
```

#### 步骤3：最终物理地址计算

```
虚拟地址: 0x12345678
页内偏移 = 虚拟地址[11:0] = 0x678

物理页基地址 = 0x40000000 (从L2页表条目获得)
最终物理地址 = 物理页基地址 + 页内偏移
             = 0x40000000 + 0x678
             = 0x40000678
```

### 完整的内存访问过程

```
虚拟地址: 0x12345678
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤1: L1页表查找                                       │
│ L1索引 = 0x123                                         │
│ L1条目地址 = 0x20000000 + (0x123 × 4) = 0x2000048C     │
│ 读取[0x2000048C] → 得到L2页表基地址 0x30000000         │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤2: L2页表查找                                       │
│ L2索引 = 0x45                                          │
│ L2条目地址 = 0x30000000 + (0x45 × 4) = 0x30000114      │
│ 读取[0x30000114] → 得到物理页基地址 0x40000000         │
└─────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤3: 计算最终地址                                     │
│ 页内偏移 = 0x678                                       │
│ 最终物理地址 = 0x40000000 + 0x678 = 0x40000678         │
└─────────────────────────────────────────────────────────┘
```

### 为什么需要两次查找？

1. **L1页表**：告诉系统"这个1MB的虚拟地址空间对应的L2页表在哪里"
2. **L2页表**：告诉系统"这个4KB的虚拟页面对应的物理页面在哪里"

### 页表条目的实际内容

```
L1页表条目 (4字节):
┌─────────┬─────────┬─────────┬─────────┐
│ 31:12   │ 11:10   │ 9:2     │ 1:0     │
├─────────┼─────────┼─────────┼─────────┤
│ L2页表  │ 域      │ 保留    │ 类型    │
│ 基地址  │         │         │         │
└─────────┴─────────┴─────────┴─────────┘

L2页表条目 (4字节):
┌─────────┬─────────┬─────────┬─────────┐
│ 31:12   │ 11:10   │ 9:2     │ 1:0     │
├─────────┼─────────┼─────────┼─────────┤
│ 物理页  │ 域      │ 保留    │ 类型    │
│ 基地址  │         │         │         │
└─────────┴─────────┴─────────┴─────────┘
```

### L1页表条目类型

| 类型 | 描述 | 用途 |
| :--- | :--- | :--- |
| **粗页表描述符** | 指向L2页表 | 需要进一步查找L2页表 |
| **段描述符** | 直接映射1MB段 | 直接转换，无需L2页表 |
| **细页表描述符** | 指向L2页表 | 需要进一步查找L2页表 |
| **无效条目** | 未定义 | 产生页错误异常 |

### 粗页表与细页表的区别

#### 粗页表描述符 (Coarse Page Table Descriptor)

- **L2页表大小**：1KB，包含256个条目
- **L2页表条目大小**：4字节
- **支持的页面大小**：4KB、64KB、1MB
- **内存占用**：相对较少
- **查找精度**：较粗，适合大块内存映射

#### 细页表描述符 (Fine Page Table Descriptor)

- **L2页表大小**：4KB，包含1024个条目
- **L2页表条目大小**：4字节
- **支持的页面大小**：1KB、4KB、64KB
- **内存占用**：相对较多
- **查找精度**：较细，适合小块内存映射

#### 对比表格

| 特性 | 粗页表 | 细页表 |
| :--- | :--- | :--- |
| **L2页表大小** | 1KB | 4KB |
| **L2条目数量** | 256个 | 1024个 |
| **最小页面** | 4KB | 1KB |
| **内存开销** | 较小 | 较大 |
| **适用场景** | 大块内存映射 | 精细内存管理 |
| **查找范围** | 1MB虚拟地址空间 | 4MB虚拟地址空间 |

#### 选择原则

- **使用粗页表**：当需要映射大块连续内存时，如代码段、数据段
- **使用细页表**：当需要精细内存管理时，如堆栈、小对象分配
- **混合使用**：在实际系统中，通常根据内存区域的特点选择合适的页表类型

### L2页表条目类型

| 类型 | 描述 | 用途 |
| :--- | :--- | :--- |
| **小页描述符** | 4KB页面 | 最常用的页面大小 |
| **大页描述符** | 64KB页面 | 大块内存映射 |
| **极小页描述符** | 1KB页面 | 小块内存映射 |
| **无效条目** | 未定义 | 产生页错误异常 |

### 实际例子

假设虚拟地址 `0x12345678` 的转换过程：

1. **L1查找**：`0x123` → L1页表[0x123] → 得到L2页表地址
2. **L2查找**：`0x45` → L2页表[0x45] → 得到物理页基地址
3. **地址计算**：物理页基地址 + `0x678` = 最终物理地址

### 两级页表的优势

| 优势 | 说明 |
| :--- | :--- |
| **节省内存** | 只为实际使用的虚拟地址空间分配页表，未使用的区域不占用页表空间 |
| **灵活性** | 可以按需分配页表，支持稀疏的虚拟地址空间 |
| **可扩展性** | 支持大容量的虚拟地址空间管理 |
| **权限控制** | 可以在页目录和页表两个层次设置不同的访问权限 |

### 页表项结构

```
页目录项/页表项 (32位):
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│ 31:12   │ 11:8    │ 7:6     │ 5:4     │ 3:2     │ 1:0     │
├─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│ 基地址  │ 保留     │ 域      │ 保留    │ 访问权限 │ 类型    │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
```

- **基地址 (31:12)**：页表或物理页的基地址
- **域 (7:6)**：访问控制域
- **访问权限 (3:2)**：读写权限控制
- **类型 (1:0)**：条目类型（页目录项/页表项/段描述符等）

### TLB与L1/L2页表的关系

- **TLB命中**：直接使用缓存的转换结果，无需访问L1和L2页表
- **TLB未命中**：需要访问L1页表 → L2页表进行地址转换
- **TLB更新**：将转换结果存入TLB供后续使用
- **性能优化**：TLB大大减少了访问L1和L2页表的内存开销

## CP15-系统控制协处理器

1. 包含16个32位的寄存器，编号为0~15
2. 对MMU进行配置，完成存储器系统管理
    - 页表和TLB
    - 域和访问权限
    - Cache和谐缓冲器（Write Buffer）
    - 快速上下文切换

### CP15中与MMU相关的寄存器

| 寄存器 | 作用 |
| :----- | :--- |
| **C1中某些位** | 用于配置MMU中的一些操作 |
| **C2** | 保存主存中页表的基地址 |
| **C3** | 设置域(domain)的访问控制属性 |
| **C4** | 保留 |
| **C5** | 主存访问失效状态指示 |
| **C6** | 主存访问失效时的地址 |
| **C8** | 控制与清除TLB内容相关的操作 |
| **C10** | 控制与锁定TLB内容相关的操作 |

### 禁止与使能MMU

1. 寄存器C1的位[0]用于设置禁止/使能MMU。
    - C1的位[0]=0时，禁止
    - C1的位[0]=1时，使能

### 禁止MMU

- 虚拟地址 = 物理地址：平板地址映射模式。
- 没有存储访问权限控制，MMU也不会产生异常信号。
- 是否支持Cache和写缓冲有具体芯片设计确定。

### 禁止/使能MMU的注意事项

- 使能之前，要先哎主存中建立页表，同时CP15相关寄存器必须初始化
- 若设计的物存和虚存不相等，则禁止/使能时，两者对饮关系会变化，需清楚Cache的地址转换条目
- 完成之后，物存与许村相同

### 存储访问权限控制

| AP | S | R | 特权级时访问权限 | 用户级时访问权限 |
| :--- | :--- | :--- | :--- | :--- |
| **0b00** | 0 | 0 | 没有访问权限 | 没有访问权限 |
| **0b00** | 1 | 0 | 只读 | 没有访问权限 |
| **0b00** | 0 | 1 | 只读 | 只读 |
| **0b00** | 1 | 1 | 不可预知 | 不可预知 |
| **0b01** | X | X | 读/写 | 没有访问权限 |
| **0b10** | X | X | 读/写 | 只读 |
| **0b11** | X | X | 读/写 | 读/写 |

> **说明**：X表示"无关"位，AP为0b01、0b10、0b11时，S和R位的值不影响访问权限

### 域

- 定义：一些段、大页或者小页的集合。
- ARM920T支持最大16个域，每域的访问控制特性由CP15中C3的两位来控制。

| 控制位编码 | 访问类型 | 含义 |
| :--------- | :------- | :--- |
| **0b00** | 没有访问权限 | 若访问该域将产生访问失效 |
| **0b01** | 客户类型 | 根据页表中地址转换条目的访问权限控制位，决定是否允许特定的存储访问 |
| **0b10** | 保留 | 使用该值会产生不可预知的结果 |
| **0b11** | 管理者权限 | 不考虑页表中地址转换条目的访问权限控制位，这种情况下不会产生访问失效 |

### 存储访问失效

- MMU可以产生四种：
    1. 地址对齐失效
    2. 地址变换失效
    3. 域控制失效
    4. 访问权限控制失效
- 发生存储访问失效时，存储系统可以中止3种存储访问：Cache内容预取、非缓冲的存储器访问操作、页表访问。
- 检测机制：
    1. MMU失效：MMU检测到后，告知微处理器，信息保存至C5和C6。
    2. 外部存储访问中止：存储系统想微处理器报告存储访问失效。
    3. 以上两种称为存储访问中止。
- 存储访问中止异常：
    1. 数据访问中止异常：在数据访问周期出现存储访问失效时产生。
    2. 在指令预取周期出现存储访问失效，在执行该指令时产生。

# ARM微处理器异常处理

## ARM微处理器执行程序的方式

1. 正常执行，一条ARM，PC加4字节；一条Thumb，PC加2字节
2. 遇到跳转指令（B、BL、BLX和BX）等方式，程序可跳转
3. 正常执行时暂时的停止，称为异常。

## ARM异常类型

| 异常类型 | 异常模式 | 具体含义 |
| :------- | :------- | :------- |
| **复位** | SVC | 当复位电平有效时，产生复位异常，微处理器切换到SVC模式，程序跳转到初始执行点 |
| **未定义指令** | UND | 当遇到无法处理的指令时，产生未定义指令异常 |
| **软件中断** | SVC | 当执行SWI指令时产生，用于用户模式下的程序调用特权操作指令 |
| **指令预取中止** | ABT | 当微处理器预取的指令地址不存在，或不允许访问该地址时，产生指令预取中止异常 |
| **数据访问中止** | ABT | 当数据访问指令的地址不存在，或当前指令不允许访问该地址时，产生数据访问中止异常 |
| **IRQ (外部中断)** | IRQ | 当外部中断请求有效，且CPSR中的I位为0时，产生IRQ异常 |
| **FIQ (快速中断)** | FIQ | 当快速中断请求有效，且CPSR中的F位为0时，产生FIQ异常 |

## 异常处理过程

### 异常优先级

| 异常类型 | 优先级 |
| :------- | :----- |
| **复位** | 1 (最高优先级) |
| **数据访问中止** | 2 |
| **快速中断 (FIQ)** | 3 |
| **外部中断 (IRQ)** | 4 |
| **指令预取中止** | 5 |
| **未定义指令** | 6 |
| **软件中断 (SWI)** | 7 (最低优先级) |

> **说明**：优先级数字越小，优先级越高。当多个异常同时发生时，处理器会按优先级从高到低的顺序处理异常。

### 异常向量地址

| 异常类型 | 异常模式 | 异常向量地址 |
| :------- | :------- | :----------- |
| **复位** | SVC | 0x00000000 |
| **未定义指令** | UND | 0x00000004 |
| **软件中断 (SWI)** | SVC | 0x00000008 |
| **指令预取中止** | ABT | 0x0000000C |
| **数据访问中止** | ABT | 0x00000010 |
| **IRQ (外部中断)** | IRQ | 0x00000018 |
| **FIQ (快速中断)** | FIQ | 0x0000001C |

> **说明**：异常向量地址是固定的，每个异常都有对应的向量地址。当异常发生时，处理器会跳转到对应的向量地址执行异常处理程序。


## 关于异常处理的几个概念

- 异常向量地址：一场出现后，强制从异常类型对应固定地址开始执行程序
- 异常向量表：由七个异常向量及其异常处理函数跳转关系组成的表。

| 异常类型 | 异常模式 | 低向量地址 (默认使用) | 高向量地址 |
| :------- | :------- | :------------------- | :--------- |
| **复位** | SVC | 0x00000000 | 0xFFFF0000 |
| **未定义指令** | UND | 0x00000004 | 0xFFFF0004 |
| **软件中断 (SWI)** | SVC | 0x00000008 | 0xFFFF0008 |
| **指令预取中止** | ABT | 0x0000000C | 0xFFFF000C |
| **数据访问中止** | ABT | 0x00000010 | 0xFFFF0010 |
| **外部中断 (IRQ)** | IRQ | 0x00000018 | 0xFFFF0018 |
| **快速中断 (FIQ)** | FIQ | 0x0000001C | 0xFFFF001C |

> **说明**：
> - **低向量地址**：默认使用的向量表，位于内存起始位置
> - **高向量地址**：可选的向量表，位于内存高端地址
> - 通过CP15寄存器C1的V位可以选择使用低向量地址还是高向量地址

## ARM处理器处理异常的具体步骤

1. 将下一条指令地址存入相应LR。
2. CPSR内容复制到SPSR
3. 根据类型，设置CPSR运行模式位
4. 强制PC从异常向量地址取吓一跳指令执行，从而跳转到相应的异常处理程序处。同时设置中断禁止位。

> 若当前是Thumb，则异常向量地址载入PC时，处理器会自动切换到ARM状态。

## ARM处理器异常返回的具体步骤

1. LR减去偏置之后送入PC
2. SPSR复制回CPSR
3. 清除中断禁止位。
4. 复位异常处理程序不需要返回。

### 异常返回地址

| 异常类型 | 返回指令 | R14_mode保存的地址 (ARM 状态) | R14_mode保存的地址 (Thumb 状态) |
| :------- | :------- | :---------------------------- | :------------------------------ |
| **BL(※)** | MOV PC, R14 | PC-4 | PC-2 |
| **SWI** | MOVS PC, R14_svc | PC-4 | PC-2 |
| **UDEF** | MOVS PC, R14_und | PC-4 | PC-2 |
| **FIQ** | SUBS PC, R14_fiq, #4 | PC'-4(=PC) | PC+2 |
| **IRQ** | SUBS PC, R14_irq, #4 | PC'-4(=PC) | PC+2 |
| **PABT** | SUBS PC, R14_abt, #4 | PC-4 | PC |
| **DABT** | SUBS PC, R14_abt, #8 | PC'-4(=PC) | PC+4 |
| **RESET** | NA | — | — |

> **说明**：
> - **R14_mode**：在进入异常模式时，当前模式的R14寄存器（链接寄存器）会保存返回地址
> - **PC**：程序计数器，指向当前正在执行的指令
> - **PC'**：在某些异常中，R14保存的地址是异常指令的地址加上一个偏移量
> - **ARM状态**：处理器在ARM指令集下运行
> - **Thumb状态**：处理器在Thumb指令集下运行
> - **BL(※)**：BL指令本身不是异常，但其返回机制与异常处理类似

## 各类异常具体描述

### 复位

- 有复位信号，立刻停止当前指令
- 复位后，在禁止中断地SVC下

### 未定义指令异常

- 执行协处理器指令时，需等待任一外部协处理器应答。若无，则会出现未定义指令异常。
- 若无物理协处理器，则软件仿真。
- 发生异常后，用MOV PC,R14_und，到该指令下一条。

### 软件中断异常

- 执行SWI指令产生，客户进行软禁仿真。
- 发生异常后，用MOV PC,R14_svc，到该指令下一条。

### 指令预取中止

预取指令不存在，SUBS PC,R14_abt, #4

> 仅当预取指令被执行时，才会发生

### 数据访问中止

数据访问指令不存在,SUBS PC,R14_abt, #8

### IRQ异常

- 属于正常外部中断请求，系统外设可通过该异常请求中断服务。
- 触发条件：
    - 中断请求引脚n_IRQ有效
    - CPSR中的I=0（允许外部中断）

### FIQ异常

- 触发条件：
    - 中断请求引脚n_FIQ有效
    - CPSR中的F=0（允许快速中断）
- 支持数据传送和通道处理，有足够的私有寄存器。

### 异常返回位置与PC值设置

| 异常类型 | 异常返回的位置 | 需设置的PC值 | 对应的返回指令 |
| :------- | :------------- | :----------- | :------------- |
| **复位** | 无返回 | 无 | 无 |
| **未定义指令** | 未定义指令后第1条指令地址 | LR | MOVS PC, LR |
| **软中断 SWI** | SWI指令后第1条指令地址 | LR | MOVS PC, LR |
| **指令预取中止** | 本预取中止指令地址 | LR-4 | SUBS PC, LR, #4 |
| **IRQ** | 断点后第1条指令地址 | LR-4 | SUBS PC, LR, #4 |
| **FIQ** | 断点后第1条指令地址 | LR-4 | SUBS PC, LR, #4 |
| **数据预取中止** | 本数据中止指令地址 | LR-8 | SUBS PC, LR, #8 |

> **说明**：
> - **LR (Link Register)**：在进入异常时，LR寄存器会保存异常返回地址的计算基准
> - **PC (Program Counter)**：程序计数器，指向下一条要执行的指令
> - **MOVS**：移动指令，同时更新CPSR寄存器（从SPSR）
> - **SUBS**：减法指令，同时更新CPSR寄存器（从SPSR）
> - 不同的异常类型需要不同的PC值调整，以确保返回到正确的指令位置