***compiler-LLVM 整体设计***

# 目录

# 命令/工具

- llc：LLVM静态编译器，用于将.ll转换为.s
- lli：直接从LLVM位码执行程序，从.bc运行在虚拟机里面
- llvm-as：LLVM汇编器，.ll转换到.bc
- llvm-dis：LLVM反汇编器，.bc转换到.ll
- opt：LLVM优化器

# 源文件

- llvm-project/clang/lib：前端语法语义解析
- llvm-project/llvm/lib：对IR做的优化
- llvm-project/llvm/lib/Transforms：IR转换优化
- llvm-project/llvm/lib/Transforms/lib/Targets：转换到目标后端

# AST结构

clang -Xclang -ast-dump -fsyntax-only test.c

细分为：delaration(Decl)、statement(Stmt)、expression(Expr)

# IR

## IR表示

### 三种表达形式

- 内存中的表达形式，如BasicBlock、Instruction这种cpp类
- bitcode形式，这是一种序列化的二进制表示形式
- LLVM汇编形式，可读

### 四大类

- Module类：理解为一个完整的编译单元，一般来说对应一个源码文件
- Function类：对应于一个函数单元
- BasicBlock类：一个基本代码块
- Instruction类：指令类，LLVM中定义的基本操作

## 控制流图CFG

基本块的流程

### 指令

```
opt -analyze -dot-cfg-only test.ll
opt -analyze -dot-cfg-only test.ll
```
> 根据test.ll生成对应的控制流.dot文件

```
dot -Tpng ***.dot -o 1.png
```
> 根据.dot文件生成对应的.png图片

## 中间优化遍

### pass分类

- Analysis Passes
- Transform Passes
- Utility Passes

***具体位置在llvm-project/llvm/lib/Transforms/***

### pass管理器

-fno-legacy-pass-manager

***具体位置在llvm-project/llvm/lib/Transforms/IPO***

希望默认调用可以在PassManagerBuilder.cpp里面注册

## opt

```
opt -O3 -print-after-all test.ll &> y
clang -O3 -mllvm -print-after-all test.ll
```
> 这两个指令是一样的，clang中如果要做IR优化的话，需要加-mllvm参数

## 中后端优化衔接

### 1. AST 输出 ：初始LLVM IR（还不是完整SSA形式）

前端生成AST：

```cpp
// Clang前端处理
clang::CompilerInstance CI;
clang::ASTContext &Context = CI.getASTContext();
clang::ASTConsumer *Consumer = ...;

// 词法分析 → 语法分析 → 生成AST
clang::ParseAST(CI.getSema());
```

AST(对应`int main() { return 0; }`)：

```ast
TranslationUnitDecl
└── FunctionDecl: main
    ├── CompoundStmt
    │   └── ReturnStmt
    │       └── IntegerLiteral: 0
```

转换

```cpp
// CodeGen模块将AST转换为LLVM IR
clang::CodeGen::CodeGenModule CGM(...);
clang::CodeGen::CodeGenFunction CGF(...);

// 遍历AST生成IR
CGF.EmitStmt(FunctionBody);
```

生成的初始LLVM IR ：

```llvm
define i32 @main() {
entry:
  %retval = alloca i32
  store i32 0, i32* %retval
  %0 = load i32, i32* %retval
  ret i32 %0
}
```

> **注意** ：此时还不是纯SSA形式，仍有内存操作（alloca/store/load）。

### 2. Mem2Reg Pass：转换为SSA形式

将内存操作提升为SSA寄存器

- **输入** ：带有内存操作的LLVM IR
- **输出** ：纯SSA形式的LLVM IR

```llvm
define i32 @main() {
entry:
  ret i32 0
}
```

- 识别alloca/store/load模式
- 用SSA值替换内存访问
- 插入φ函数处理控制流合并

### 3. LLVM IR优化阶段(PassManagerBuilder)

LLVM有丰富的优化Pass，按顺序执行：

***早期优化（在SSA化之前）***

- SimplifyCFG ：简化控制流图
- SROA ：标量替换聚合体
- InstCombine ：指令组合

***SSA优化（在SSA化之后）***

- GVN ：全局值编号
- LICM ：循环不变代码外提
- SLP ：超字级并行化

***优化Pass管理器示例 ：***

```cpp
llvm::PassManagerBuilder PMB;
PMB.OptLevel = 2;  // -O2优化级别

llvm::FunctionPassManager FPM;
FPM.add(llvm::createGVNPass());
FPM.add(llvm::createLICMPass());
FPM.run(*Function);
```

### 4. 后端处理：SelectionDAG生成

- **输入** ：优化后的LLVM IR（SSA形式）
- **输出** ：SelectionDAG

***步骤1：构建初始DAG***

```cpp
// SelectionDAG构建器
llvm::SelectionDAGBuilder DAGBuilder(...);

// 为每个基本块构建DAG
for (auto &BB : *Function) {
    DAGBuilder.visit(BB);
}
```

***步骤2：合法化（Legalize）***
确保DAG中的操作在目标架构上合法：

- **类型合法化** ：转换不支持的数据类型
- **操作合法化** ：将复杂操作分解为简单操作 步骤3：DAG优化

***步骤3：DAG优化***

在DAG层面进行优化：

- **节点合并** ：消除重复计算
- **常量折叠** ：编译时计算常量表达式
- **死代码消除** ：删除无用节点

### 5. 指令选择和代码生成

- **输入** ：优化后的SelectionDAG
- **输出** ：目标机器代码

```cpp
// 模式匹配将DAG节点映射到机器指令
llvm::TargetLowering TL(...);
llvm::SDNode *Node = ...;
llvm::SDValue Result = TL.LowerOperation(Node, DAG);
```

### 完整的LLVM Pass流水线示例

***O0（无优化）流水线：***

```txt
前端 → 初始IR → Mem2Reg → 简单优化 → 代码生成
```

***O2（标准优化）流水线：***

```txt
前端 → 初始IR → 早期优化 → Mem2Reg → 
SSA优化 → 后端优化 → 代码生成
```

***O3（激进优化）流水线：***

```txt
前端 → 初始IR → 激进优化 → Mem2Reg → 
深度SSA优化 → 向量化 → 后端优化 → 代码生
成
```

# 后端代码生成

`llvm/lib/Transforms/CodeGen`里面有一些目标无关的优化算法，包括寄存器分配之类的

## 结构设计

1. **指令选择**：主要将LLVM代码转换为目标指令的DAG。通过模式将节点匹配到机器指令，指令的描述和模式由LLVM后端开发者编写，主要使用TableGen语法在td文件中描述
2. **调度和格式化**：将指令选择完成的DAG转化为指令序列，可设置符合目标硬件的调度策略，然后根据该顺序将指令作为MachineInstrics发出
3. **基于SSA的机器代码优化**：一系列基于SSA的机器码优化，像模块调度、窥孔优化（**写在CodeGen里面的**）
4. **寄存器分配：** 目标代码从SSA形式的无限寄存器文件转换为Target使用的具体寄存器文件，引入溢出代码并消除程序中的所有虚拟寄存器引用
5. **Prolog/Epilog代码插入**：一旦为函数生成了机器码，就能推算除所需的堆栈空间量，就可以插入函数的prolog和epilog代码，并且消除抽象堆栈位置引用。此阶段负责实现优化，如帧指针消除和堆栈打包
6. **后期机器代码优化：** 对最终机器码进行操作的优化可以放在这里，比如溢出代码调度和窥视孔优化
7. **代码发射：** 最后阶段是基础当前函数的代码，生成Target汇编码或是机器码。

## 指令选择

### several question

#### 什么是元指令？

1. 不直接对应目标机器指令的抽象节点
2. 用于表示高级操作或编译器内部辅助操作的中间表示
3. 在后续阶段会被转换为实际的机器指令序列

***例子***

- **条件选择指令（如 SELECT_CC）**：
表示三元运算符 a ? b : c 或条件赋值
不同的目标架构可能用不同方式实现（如 x86 的 CMOV、ARM 的条件执行等）

- **内存屏障指令（如 MEMBARRIER）**：
表示内存同步语义
，根据目标架构转换为对应的内存屏障指令

- **地址计算指令**：
复杂地址模式可能先表示为一个抽象节点
，后续根据目标架构展开为具体指令序列

#### 什么是DAG？

DAG是一种特殊的有向图，即有向无环图

***基本特性：***

- 有向性：边是有方向的
- 无环性：不存在循环路径
- 层次结构：天然支持分层和拓扑排序

***基本特性实例：***

*有向性：*

```txt
表达式：a = (b + c) * d
```

对应DAG表示：

```txt
     * (乘法)
    / \
   +   d
  / \
 b   c
```

- 边从操作数指向操作符
- b 和 c 指向 `+` 节点
- `+`节点和 d 指向 `*` 节点
- 明确的计算依赖关系

*无环性：*

- 合法的

```txt
a = b + c
d = a * e
```

- 不合法的：

```txt
a = b + c
b = a * 2  // 循环依赖！
```

*层次结构：*

```
x = a + b
y = x * c  
z = y - d
```

层次化DAG：

```
层3:   - (z)
      / \
层2: *   d
    / \
层1: +   c
  / \
 a   b
```

***In compiler：***

- IR：如表达式数、控制流图
- 数据依赖关系：指令之间的依赖关系
- 优化表示：公共子表达式消除等优化

***compiler 实例***

*公共子表达式消除（CSE）：*

```
a = b + c
d = b + c  // 重复计算
e = a * 2
```
构建DAG：
```
     * (e)
    / \
   +   2
  / \
 b   c
  \
   a, d (共享同一个+节点)
```

*常量折叠：*

```
x = 3 + 5
y = x * 2
```
DAG构建过程 ：
```
初始DAG：
   * (y)
  / \
 +   2
/ \
3  5

优化后DAG：
   * (y)
  / \
 8   2  // 3+5被折叠为8

最终优化：
y = 16  // 8*2被折叠为16
```

***与AST的关系：***

- AST是语法导向的 ：反映代码的语法结构
- DAG是数据流导向的 ：反映计算的数据依赖关系
- AST可以转换为DAG ：通过消除语法冗余，提取数据依赖

***与SSA的关系：***

- 依赖关系更清晰 ：每个值有明确的定义点
- 优化更简单 ：无需考虑变量重定义
- 并行化更容易 ：明确的def-use链

### SelectionDAG的指令选择

LLVM IR > SelectionDAG > MachineDAG > MachineInstr > MCInst

一层层降级

1. **初始化DAG**：从LLVM代码到非法SelectionDAG的简单转换（-view-dag-combine1-dag）;
2. **优化SelectionDAG**：这个阶段对SelectionDAG执行简单的优化以简化代码，并识别元指令。以生成高效的代码，并使DAG阶段的选择指令更加简单。（-view-legalize-dags）;
3. **合法化SelectionDAG类型**：转换SelectionDAG节点，以消除Target不支持的数据类型（-view-dag-combine2-dags）;
4. **优化SelectionDAG**：清除类型合法化造成的代码冗余（-view-isel-dags）;
5. **合法化SelectionDAG操作**：转换SelectionDAG节点，以消除Target不支持的任何操作（-view-sched-dags）;
6. **优化SelectionDAG**：消除操作合法化造成的代码冗余；
7. **从DAG中选择指令**：将DAG操作与Target指令相匹配，将目标无关的输入DAG转换为Target指令的另一个DAG。
8. **SelectionDAG调度**：最后一个阶段为目标指令DAG中的指令分配一个线性顺序，并将它们发送到正在编译的MachineFunction中。

### 全局指令选择

综合了基于SelectionDAG指令选择和快速指令选择二者的优点，没有引入新的DAG表示

## 寄存器分配

LLVM支持以下四种：

1. Basic：一种增量的寄存器分配方法
2. Fast：调试构建的默认配置
3. Greedy：默认分配器。贪心策略。这是Basic分配器的一个高度调优的实现，它包含了全局活动范围的分割。
4. PBQP：基于分区布尔二次规划的寄存器分配器。

默认是贪心寄存器分配方法。

## 编写后端

1. 创建TargetMachine类的子类来描述目标机器的特性。
2. 描述目标平台的寄存器集，用TableGen从一个特定目标平台的RegisterInfo.td输入文件来生成寄存器定义、别名、类。
3. 描述目标平台的指令集。通过TableGen使用特定目标平台版本的TargetInstrFormat.td和TargetInstrInfo.td来生成
4. 描述从指令的DAG到本地目标机器平台的指令的LLVM IR 的选择与转化。用TableGen来生成匹配模式的代码和选择基于目标特定版本的TargetInstrInfo.td中额外信息的指令，并再XXXIselLowering.cpp编写代码来替换或者删除在SelectionDAG中不被本地支持操作和数据类型。
5. 编写将LLVM IR转为GAS格式的汇编打印器。