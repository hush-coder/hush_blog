***compiler-basic 语义分析***

# 目录

# 什么是语义分析？

```
源代码 → [词法分析] → 令牌流 → [语法分析] → 语法树 → [语义分析] → 带注解的语法树
```

- 建立符号表：记录所有标识符的信息
- 类型检查：确保运算和赋值的类型兼容
- 作用域分析：确定标识符的可见范围
- 其他检查：函数调用匹配、继承关系等

# 符号表

## 基本结构

```cpp
// 符号表项：记录一个标识符的所有信息
struct Symbol {
    std::string name;       // 标识符名称
    Kind kind;              // 种类：变量、函数、类等
    Type* type;             // 类型信息
    int scopeLevel;         // 作用域层级
    int memoryOffset;       // 内存偏移（用于代码生成）
    // 其他属性...
};

// 符号表：管理所有符号
class SymbolTable {
private:
    std::vector<Symbol> symbols;  // 所有符号的集合
    // 更多实现细节...
};
```

## 符号种类

```cpp
enum class Kind {
    VARIABLE,    // 变量
    FUNCTION,    // 函数  
    CLASS,       // 类
    METHOD,      // 方法
    PARAMETER,   // 参数
    FIELD        // 字段（类的成员变量）
};
```

# 作用域管理

## 什么是作用域？

```java
// 全局作用域
var x = 1;

function test() {
    // 函数作用域
    var x = 2;  // 遮蔽全局的x
    var y = 3;  // 只在函数内可见
    
    {
        // 块作用域
        var z = 4;  // 只在块内可见
    }
    // z 在这里不可见
}
```

## 栈式符号表实现

```cpp
class StackSymbolTable {
private:
    // 每个作用域是一个独立的映射表
    std::vector<std::unordered_map<std::string, Symbol>> scopes;

public:
    // 进入新作用域
    void enterScope() {
        scopes.push_back(std::unordered_map<std::string, Symbol>());
    }
    
    // 退出当前作用域
    void exitScope() {
        if (!scopes.empty()) {
            scopes.pop_back();
        }
    }
    
    // 在当前作用域插入符号
    bool insert(const Symbol& symbol) {
        if (scopes.empty()) return false;
        
        auto& currentScope = scopes.back();
        if (currentScope.find(symbol.name) != currentScope.end()) {
            return false;  // 重复定义
        }
        
        currentScope[symbol.name] = symbol;
        return true;
    }
    
    // 查找符号（从内到外）
    Symbol* lookup(const std::string& name) {
        // 从最内层作用域开始向外查找
        for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
            auto found = it->find(name);
            if (found != it->end()) {
                return &found->second;
            }
        }
        return nullptr;  // 未找到
    }
    
    // 只在当前作用域查找（用于检查重复定义）
    Symbol* lookupCurrentScope(const std::string& name) {
        if (scopes.empty()) return nullptr;
        auto found = scopes.back().find(name);
        if (found != scopes.back().end()) {
            return &found->second;
        }
        return nullptr;
    }
};
```

## 作用域的使用示例

```cpp
void processFunction(ASTNode* function) {
    symbolTable.enterScope();  // 进入函数作用域
    
    // 添加参数到符号表
    for (auto param : function->parameters) {
        Symbol paramSymbol{param->name, Kind::PARAMETER, param->type};
        symbolTable.insert(paramSymbol);
    }
    
    // 处理函数体
    processBlock(function->body);
    
    symbolTable.exitScope();  // 退出函数作用域
}
```

# 类型系统的设计

## 类型层次结构

```cpp
// 所有类型的基类
class Type {
public:
    virtual ~Type() = default;
    virtual std::string getName() const = 0;
    virtual bool isAssignableFrom(const Type* other) const = 0;
    virtual bool isEquivalentTo(const Type* other) const = 0;
};

// 基本类型：int, float, bool, void等
class BasicType : public Type {
private:
    std::string name;
    
public:
    BasicType(const std::string& name) : name(name) {}
    
    std::string getName() const override { return name; }
    
    bool isAssignableFrom(const Type* other) const override {
        if (auto otherBasic = dynamic_cast<const BasicType*>(other)) {
            // 基本类型之间的赋值规则
            if (name == "float" && otherBasic->name == "int") {
                return true;  // int可以赋值给float
            }
            return name == otherBasic->name;
        }
        return false;
    }
    
    bool isEquivalentTo(const Type* other) const override {
        return isAssignableFrom(other) && 
               dynamic_cast<const BasicType*>(other) &&
               dynamic_cast<const BasicType*>(other)->getName() == name;
    }
};

// 类类型
class ClassType : public Type {
private:
    std::string className;
    ClassType* parentClass;  // 父类
    
public:
    std::string getName() const override { return className; }
    
    bool isAssignableFrom(const Type* other) const override {
        if (isEquivalentTo(other)) return true;
        
        if (auto otherClass = dynamic_cast<const ClassType*>(other)) {
            // 检查继承关系：如果otherClass是当前类的子类，可以赋值
            ClassType* current = otherClass->parentClass;
            while (current != nullptr) {
                if (current == this) return true;
                current = current->parentClass;
            }
        }
        return false;
    }
    
    bool isEquivalentTo(const Type* other) const override {
        if (auto otherClass = dynamic_cast<const ClassType*>(other)) {
            return className == otherClass->className;
        }
        return false;
    }
};
```

## 类型环境

```cpp
class TypeEnvironment {
private:
    std::unordered_map<std::string, Type*> types;
    
public:
    // 注册类型
    void registerType(const std::string& name, Type* type) {
        types[name] = type;
    }
    
    // 查找类型
    Type* getType(const std::string& name) {
        auto it = types.find(name);
        if (it != types.end()) {
            return it->second;
        }
        return nullptr;
    }
    
    // 类型提升（用于算术运算）
    Type* promoteTypes(Type* left, Type* right) {
        if (left->getName() == "double" || right->getName() == "double") {
            return getType("double");
        }
        if (left->getName() == "float" || right->getName() == "float") {
            return getType("float");
        }
        if (left->getName() == "long" || right->getName() == "long") {
            return getType("long");
        }
        return getType("int");  // 默认int
    }
};
```

# Visitor模式遍历AST

- 语义分析需要在AST上进行多次遍历
- 不同的遍历执行不同的检查
- Visitor模式将算法与数据结构分离

## Visitor基类

```cpp
// 前向声明所有AST节点类型
class Program;
class FunctionDecl;
class VarDecl;
class Block;
class Assignment;
class BinaryOp;
class Identifier;
// ... 其他节点类型

// Visitor基类
class ASTVisitor {
public:
    virtual ~ASTVisitor() = default;
    
    virtual void visit(Program* node) = 0;
    virtual void visit(FunctionDecl* node) = 0;
    virtual void visit(VarDecl* node) = 0;
    virtual void visit(Block* node) = 0;
    virtual void visit(Assignment* node) = 0;
    virtual void visit(BinaryOp* node) = 0;
    virtual void visit(Identifier* node) = 0;
    // ... 其他visit方法
};
```

***多次检查遍历！！！***