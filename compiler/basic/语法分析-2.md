***compiler-basic 语法分析-2***

# 目录

# 自底向上分析法

## 与自顶向下对比：

- **自顶向下**：从盒子上的完整图片开始，逐步分解成小块
- **自底向上**：从一堆零散碎片开始，逐步拼成完整图片

## 工作方式：

1. 从输入令牌序列开始（树叶）
2. 识别出可以归约的片段
3. 用非终结符替换这些片段（向上组合）
4. 重复直到归约为开始符号（树根）

## 句柄

```
文法: E -> E + T | T, T -> T * F | F, F -> ( E ) | id
输入: id + id * id

分析过程:
id + id * id  →  F + id * id  (F -> id)
F + id * id   →  T + id * id  (T -> F)  
T + id * id   →  E + id * id  (E -> T)
E + id * id   →  E + F * id   (F -> id)
E + F * id    →  E + T * id   (T -> F)
E + T * id    →  E + T * F    (F -> id)
E + T * F     →  E + T        (T -> T * F)
E + T         →  E            (E -> E + T)
```

# LR分析法

- **L**：从左向右扫描输入
- **R**：产生最右推导

分析方法 | 能力 | 状态数 | 实际应用
| :--- | :--- | :--- | :--- |
LR(0) | 最弱 | 最少 | 几乎不用，教学用途
SLR(1) | 较弱 | 较少 | 简单语言
LR(1) | 最强 | 最多 | 理论完美，实际较少
LALR(1) | 很强 | 中等 | 工业标准（Yacc、Bison）

# LR分析器核心组件

```python
class LRAnalyzer:
    def __init__(self):
        self.stack = []          # 状态栈
        self.symbols = []        # 符号栈  
        self.input_tokens = []   # 输入缓冲区
        self.action_table = {}   # ACTION表
        self.goto_table = {}     # GOTO表
```

## 状态栈

LR分析器的记忆单元，记录分析过程中的所有状态轨迹。

```python
# 状态栈示例
状态栈 = [0, 3, 5, 8]  # 栈顶在右边
```

### what job?

- **跟踪分析进度**：每个状态代表分析器当前"知道"的语法信息
- **支持回溯**：当需要归约时，告诉分析器要回溯多远
- **维护上下文**：记录当前所在的语法结构层次

### 工作原理

- **初始状态**：总是从状态0开始
- **状态转移**：根据输入符号和当前状态决定下一个状态
- **状态回溯**：归约时弹出多个状态，回到之前的分析点

## 符号栈

符号栈存储已经识别出的文法符号（终结符和非终结符）。

```python
# 符号栈示例  
符号栈 = ['E', '+', 'T']  # 栈顶在右边
```

### what job?

- **存储识别结果**：记录已经成功分析的语法结构
- **构建语法树**：为后续的抽象语法树构建提供基础
- **支持归约**：提供归约时需要的符号序列

### 工作原理

- **移进时**：将输入符号压入栈
- **归约时**：弹出多个符号，压入归约得到的非终结符
- **与状态栈同步**：符号栈的每个符号对应状态栈的一个状态

## ACTION表

ACTION表是LR分析器的决策引擎，告诉分析器**在特定状态下遇到特定输入符号时**该做什么。

```python
# ACTION表示例结构
ACTION表 = {
    状态0: {
        'id': '移进到状态5',
        '(': '移进到状态4', 
        '$': '错误'
    },
    状态1: {
        '+': '移进到状态6',
        '$': '接受'
    },
    # ... 更多状态
}
```

### what job?

- **决定下一步动作**：移进、归约、接受还是报错
- **消除歧义**：通过精确的状态-符号映射避免决策冲突
- **指导分析流程**：控制分析器的执行路径

### ACTION表的四种动作：

1. *移进（Shift）*

```python
's5'  # 移进当前符号，并转移到状态5
```
> - 时机：当需要继续读取输入时
> - 操作：消费输入符号，压入符号栈和状态栈

2. *归约（Reduce）*

```python
'r3'  # 用第3个产生式进行归约
```
> - 时机：当识别出一个完整的语法结构时
> - 操作：弹出栈顶的多个符号，压入归约得到的非终结符

3. *接受（Accept）*

```python
'acc'  # 分析成功完成
```
> - 时机：当成功归约到开始符号且输入结束时
> - 操作：终止分析，报告成功

4. *错误（Error）*

- 时机：当遇到非法输入时
- 操作：触发错误处理程序

## GOTO表

GOTO表是LR分析器的导航系统，**在归约后**告诉分析器应该转移到哪个状态。

```python
# GOTO表示例结构  
GOTO表 = {
    状态0: {
        'E': 状态1,
        'T': 状态2,
        'F': 状态3
    },
    状态4: {
        'E': 状态8
    },
    # ... 更多状态
}
```

### what job?

- **状态导航**：在归约后确定新的分析状态
- **维护连续性**：确保分析过程的状态一致性
- **处理非终结符**：专门用于非终结符引起的状态转移

### 工作原理

- **归约后调用**：当用产生式 `A → α` 归约后，栈顶状态是 `s`，查 `GOTO[s, A]`
- **确定新状态**：得到新状态 `s'`，压入状态栈
- **符号同步**：将非终结符 `A` 压入符号栈

## 总结

- 状态栈 = 分析器的"记忆"（我知道我在哪里）
- 符号栈 = 分析器的"成果"（我已经识别了什么）
- ACTION表 = 分析器的"决策"（我接下来该做什么）
- GOTO表 = 分析器的"导航"（完成一步后该去哪里）

# LR(0)分析法

*目标问题：*

如何让分析器自动识别什么时候应该移进，什么时候应该归约？

*解决方案：*

构建一个有限状态自动机，每个状态代表分析器"知道"的语法信息，状态转移代表分析进度。

## LR(0)项：进度标记

### 是什么？

$$LR(0)项 = 产生式 + 进度点$$

在产生式中间加一个点·，表示解析进度

```
产生式: A → B C D

对应的LR(0)项:
A → · B C D     # 还没开始，期待B C D
A → B · C D     # 已经看到B，期待C D  
A → B C · D     # 已经看到B C，期待D
A → B C D ·     # 全部完成！可以归约
```

### 为什么？

这个点就像书签，告诉分析器："我在这里，已经看到了这些，还期待那些"

## 闭包

- 当分析器说"我期待看到一个E"
- 闭包操作会说："好，那我也准备好所有可能产生E的方法"

### 形式化

$$闭包(I) = 项集I + 所有可以通过点后的非终结符推导出来的项$$

```
闭包(I) =
   重复直到没有新项加入：
      对于I中的每个项 [A → α · B β]：
          对于每个产生式 B → γ：
              将 [B → · γ] 加入 I
```

### 实例

*文法如下：*

```
(0) S' → S
(1) S → E
(2) E → E + T  
(3) E → T
(4) T → id
(5) T → ( E )
```

*初始项集：*

```
初始项集: { [S' → · S] }
```

*闭包扩展：*

```
初始: [S' → · S]
        ↓
       [S → · E]  
        ↓
   [E → · E + T] 和 [E → · T]
                ↓
        [T → · id] 和 [T → · ( E )]

现在项集: { 
    [S' → · S], 
    [S → · E], 
    [E → · E + T], 
    [E → · T],
    [T → · id], 
    [T → · ( E )] 
}
```

### 意义

*没有闭包的：*

```python
# 笨拙的分析器
if 当前状态是"期待S":
    if 看到E:
        转到"看到S"状态
    else:
        报错
```

*有闭包的：*

```python
# 聪明的分析器（通过闭包知道所有可能性）
if 当前状态包含[S' → · S]:
    # 闭包告诉我：为了得到S，可以期待E
    # 为了得到E，可以期待E+T或T  
    # 为了得到T，可以期待id或(E)
    # 所以我知道现在可能看到: E, T, id, (
```

***状态0的闭包告诉分析器：***

- "你现在在开始位置"
- "你接下来可能看到：`E, T, id, ( `这些符号"
- "如果看到id，就用`T → id`；如果看到`(`，就用`T→(E)...`"

