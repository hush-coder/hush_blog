# Scoreboard 机制

## SV寄存器与watcher

- SV计数器：记录"做了多少事情"
- Watcher：监视SV的信号量

## what

```
┌───────────────────────────────────────┐
│        快递中转站（Scoreboard）       │
├───────────────────────────────────────┤
│ 货架A: 已到货 10 件 ✓                 │  ← sv_cvu_w = 10
│ 货架B: 已发出 5 件 ✓                  │  ← sv_u2u_w = 5
│ 货架C: 等待中 0 件 ✗                  │  ← sv_drbt_w = 0
│                                       │
│ 监控员小王: 正在等货架C到货 ⏰        │  ← sv_watchers_sel_8
└───────────────────────────────────────┘

```

## 核心功能

***功能 1：追踪资源状态（计数器）***
```
sv_cvu_w（CVU 写计数器）
  ↓
记录"CVU 已经写了多少个数据"
  ↓
生产者写一个数据 → sv_cvu_w++
消费者读一个数据 → 检查 sv_cvu_w 是否足够
```

***功能 2：追踪指令依赖（Watcher）***

```
sv_watchers_sel_8（监视器8）
  ↓
记录"这个 Tile 在等待什么"
  ↓
如果在等待 → bit 27 = 1（0x080c0002）
如果空闲 → bit 27 = 0（0x00060002）
```

# Event机制

更新信号量

## 边缘触发（Edge-triggered）- NPU 使用这种

```
时间轴：
      ↓ 按一下门铃
━━━━━┓━━━━━━━━━━━━━━━━━
     ┗━━━━━━━━━━━━━━━━━  信号立即消失
      ↑
    只有这一瞬间有效！
    
特点：
  ✓ 效率高，不占用总线
  ✗ 如果错过了，就永远收不到
```

## 电平触发（Level-triggered）

```
时间轴：
      ↓ 按住门铃
━━━━━┓━━━━━━━━━━━┓━━━━━
     ┗━━━━━━━━━━━┛      信号持续
      ↑           ↑
    按下       松开
    
特点：
  ✓ 可以反复检查
  ✗ 占用总线资源
```

# 同步原语

## Barrier

等所有人到齐才出发的旅游团

```
Tile 0: [工作]────>│
Tile 1: [工作]──────>│
Tile 2: [工作]──>│      ├── __barrier() ──> 所有人继续
Tile 3: [工作]───────>│
                    ↑
                  等待点
```

## Fence（栅栏）

确保内存操作完成

```
写内存：
  Tile 0: write(addr, data);
  Tile 0: __fence();  // 确保写入真的完成了，不在缓存里
  Tile 0: 通知其他 Tile

读内存：
  Tile 1: 收到通知
  Tile 1: __fence();  // 确保读取到最新数据
  Tile 1: read(addr);
```

# Hang问题

```
1. 互斥（Mutual Exclusion）
   → 资源只能被一个进程占用

2. 持有并等待（Hold and Wait）
   → 进程持有资源，同时等待其他资源

3. 非抢占（No Preemption）
   → 资源不能被强制夺走

4. 循环等待（Circular Wait）
   → A 等 B，B 等 C，C 等 A
```

## 为什么 reset_sv() 会导致死锁？

***破坏了"事件一致性"：***

```
正常流程（无 reset）：
  T1: Tile 0 写数据 → sv_cvu_w = 100
  T2: Tile 0 触发 Event X
  T3: Tile 1 收到 Event X
  T4: Tile 1 检查 sv_cvu_w = 100 ✓
  T5: Tile 1 读取数据

错误流程（有 reset）：
  T1: Tile 0 写数据 → sv_cvu_w = 100
  T2: Tile 0 触发 Event X
  T3: reset_sv() 执行：
      - Event X 被清空 ✗
      - sv_cvu_w 被清零 ✗
  T4: Tile 1 去等待 Event X → 永远等不到
  T5: Tile 1 检查 sv_cvu_w = 0 → 以为没准备好
  T6: Tile 0 重新累积 sv_cvu_w = 100
      但认为自己已经触发过 Event X，不再触发
  T7: 死锁！
```

# Ping-Pong Buffer(双缓冲机制)

## 主要原理

***传统单缓冲：***

```
写入 Buffer → 等待写完 → 读取 Buffer → 等待读完 → 重复
```

***双缓冲：***

```
  写入 Ping Buffer ──┐
                     ├→ 同时进行
  读取 Pong Buffer ──┘
  
  然后交换：
  写入 Pong Buffer ──┐
                     ├→ 同时进行
  读取 Ping Buffer ──┘
```