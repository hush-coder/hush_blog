# several questions

## 为什么要进行指针的类型转换？

首先理解NPU内存层次

```
┌─────────────────────────────────────────────────────────┐
│                    DDR (全局内存)                        │
│                   物理地址空间                            │
└─────────────────────────────────────────────────────────┘
                        ↓ DMA
┌─────────────────────────────────────────────────────────┐
│              Global Memory (跨Tile共享)                  │
└─────────────────────────────────────────────────────────┘
                        ↓
        ┌───────────────┴───────────────┐
        ↓                               ↓
┌───────────────┐               ┌───────────────┐
│   Tile 0      │               │   Tile 1      │
│  ┌─────────┐  │               │  ┌─────────┐  │
│  │ Local   │  │               │  │ Local   │  │
│  │ Memory  │  │  ...32个...   │  │ Memory  │  │
│  │(__tm__) │  │               │  │(__tm__) │  │
│  └─────────┘  │               │  └─────────┘  │
└───────────────┘               └───────────────┘

```

### 指针类型系统

#### 1. __ltptr (Local Tile Pointer)
**定义**：指向当前 Tile 本地内存的指针

**特点**：
- 只能访问自己所在的 Tile的内存
- 地址空间是本地的（每个 Tile 独立）
- 最快的访问速度（单周期延迟）
- 编译器可以做最激进的优化

**适用场景**：
- Tile 内部的局部计算
- 不需要跨 Tile 访问
- 性能关键路径

#### 2. __gptr (Global Pointer)
**定义**：指向任意 Tile 内存的指针

**特点**：
- 可以访问其他 Tile 的内存
- 地址编码包含 Tile ID
- 访问速度较慢（需要片上网络路由）
- 编译器优化受限
**适用场景**：

- 跨 Tile 数据传输
- 需要向其他 Tile 写入数据
- 多 Tile 协作

### 核心区别

关键问题：
- 每个 Tile 有独立的地址空间
- 地址 0x1000 在不同 Tile 上指向不同的物理内存
- 没有硬件 MMU 来统一管理

***原因1：生成不同的机器指令***

```cpp
// 代码1：本地访问
fp16_t(*__ltptr ptr) = &local_data[0];
*ptr = 1.0;

// 汇编
; Local Tile 访问
load.local  r1, [local_base + 0x1000]   ; 1条指令，直接访问
store.local [local_base + 0x1000], r1   ; 1条指令

// 代码2：远程访问
fp16_t(*__gptr ptr) = __to_gptr(5, &local_data[0]);
*ptr = 2.0;

// 生成的汇编
; Global 访问
move   r1, #5              ; Tile ID
shl    r1, #16             ; 移位到高位
or     r1, #0x1000         ; 组合本地偏移
                           
send   r1, r2, REMOTE      ; 发送写请求到片上网络
wait   ack                 ; 等待确认

```

***原因2：地址编码方式不同***

1. `__ltptr` 的地址格式
```
┌─────────────────────────────────┐
│     20-bit Local Offset         │
└─────────────────────────────────┘
0                                 19
```
> 范围: 0x00000 - 0xFFFFF (1MB)

2. `__gptr` 的地址格式

┌──────────────┬──────────────────┐
│  Tile ID (6) │ Local Offset(20) │
└──────────────┴──────────────────┘
26            19                  0
> 范围: 64 tiles × 1MB = 64MB

3. 编译器需要知道：

- 是否需要编码 Tile ID
- 如何生成地址计算指令

***原因3：优化策略完全不同***

1. `__ltptr` 的优化

```cpp
fp16_t(*__ltptr ptr)[100];


// 编译器可以：
// 1. 做循环展开
for (int i = 0; i < 100; i++) {
    ptr[i] = ...;
}
// → 生成硬件预取指令
// → 向量化加载（一次加载多个元素）

// 2. 寄存器分配
// → 地址可以常驻寄存器
// → 无需每次重新计算

// 3. 消除边界检查
// → 编译器知道地址范围
```

2. `__gptr` 的约束

```cpp
fp16_t(*__gptr ptr)[100];

// 编译器必须：
// → 每次访问都可能跨网络
// → 不能随意重排

// 2. 插入同步
// → 可能需要内存屏障
// → 等待远程操作完成

// 3. 避免预测执行
// → 远程访问延迟不确定
```