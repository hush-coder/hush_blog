# 数学定义

```
输入: Input [H_in, W_in, C_in]
卷积核: Kernel [K, K, C_in, C_out]
输出: Output [H_out, W_out, C_out]

对于每个输出像素 output[h, w, c_out]:
  output[h,w,c_out] = Σ Σ Σ input[h+kh, w+kw, c_in] × kernel[kh,kw,c_in,c_out]
                      kh kw c_in
```

# Im2Col

## 核心思想
将卷积变成 `GEMM (General Matrix Multiply)`:

```
Output = Im2Col(Input) × Kernel_reshaped
```
## 为什么要这样做？

- ✅ GEMM 是最优化的操作（几十年优化）
- ✅ 可以利用高度优化的 BLAS 库（如 ARM Compute Library, cuBLAS）
-  ✅ 批量数据重用，缓存友好

## 详细过程

### 示例信息
- **输入:** 5×5×3 图像 (H=5, W=5, C=3)
- **卷积核:** 3×3×3×2 (K=3, C_in=3, C_out=2)
- **输出:** 3×3×2 (stride=1, padding=0)

### Step1：展开输入(Im2Col)

```
// 原始输入: [H=5][W=5][C=3]
Input[5][5][3] = {
    // 第一行
    {{R00,G00,B00}, {R01,G01,B01}, {R02,G02,B02}, {R03,G03,B03}, {R04,G04,B04}},
    // 第二行
    {{R10,G10,B10}, {R11,G11,B11}, {R12,G12,B12}, {R13,G13,B13}, {R14,G14,B14}},
    // ...
};

// Im2Col 后: [输出像素数 × (K×K×C_in)]
//           = [9 × 27] 矩阵
Im2Col_Matrix[9][27] = {
    // 第1个输出像素 (0,0): 对应输入窗口 [0:3, 0:3, :]
    [R00,G00,B00, R01,G01,B01, R02,G02,B02,  // 第0行
     R10,G10,B10, R11,G11,B11, R12,G12,B12,  // 第1行
     R20,G20,B20, R21,G21,B21, R22,G22,B22], // 第2行
    
    // 第2个输出像素 (0,1): 对应输入窗口 [0:3, 1:4, :]
    [R01,G01,B01, R02,G02,B02, R03,G03,B03,  // 窗口向右滑动1格
     R11,G11,B11, R12,G12,B12, R13,G13,B13,
     R21,G21,B21, R22,G22,B22, R23,G23,B23],
    
    // 第3个输出像素 (0,2): 窗口继续滑动
    [R02,G02,B02, R03,G03,B03, R04,G04,B04,
     R12,G12,B12, R13,G13,B13, R14,G14,B14,
     R22,G22,B22, R23,G23,B23, R24,G24,B24],
    
    // 第4个输出像素 (1,0): 窗口向下滑动
    [R10,G10,B10, R11,G11,B11, R12,G12,B12,
     R20,G20,B20, R21,G21,B21, R22,G22,B22,
     R30,G30,B30, R31,G31,B31, R32,G32,B32],
    
    // ... 共9行 (3×3个输出位置)
};
```

### Step2：重塑卷积核

```
// 原始卷积核: [K=3][K=3][C_in=3][C_out=2]
Kernel[3][3][3][2] = {
    // 第一个输出通道
    {{{W0_r, W0_g, W0_b}, ...}, ...},  // 3×3×3 = 27 个权重
    
    // 第二个输出通道
    {{{W1_r, W1_g, W1_b}, ...}, ...},  // 3×3×3 = 27 个权重
};

// 重塑为: [(K×K×C_in) × C_out] = [27 × 2]
Kernel_reshaped[27][2] = {
    //  C_out=0  C_out=1
    [  W0[0,0,0], W1[0,0,0] ],  // R 通道，位置 (0,0)
    [  W0[0,0,1], W1[0,0,1] ],  // G 通道，位置 (0,0)
    [  W0[0,0,2], W1[0,0,2] ],  // B 通道，位置 (0,0)
    [  W0[0,1,0], W1[0,1,0] ],  // R 通道，位置 (0,1)
    // ... 共 27 行
};
```

### Step3：矩阵乘法(GEMM)

```
// Output = Im2Col_Matrix × Kernel_reshaped
//        = [9 × 27] × [27 × 2]
//        = [9 × 2]

Output[9][2] = Im2Col_Matrix[9][27] @ Kernel_reshaped[27][2]

// 展开第一个输出像素的计算:
Output[0][0] = Im2Col_Matrix[0][:] · Kernel_reshaped[:][0]
             = R00×W0[0,0,0] + G00×W0[0,0,1] + B00×W0[0,0,2]  // 位置(0,0)的RGB
             + R01×W0[0,1,0] + G01×W0[0,1,1] + B01×W0[0,1,2]  // 位置(0,1)的RGB
             + R02×W0[0,2,0] + ...                            // 位置(0,2)的RGB
             + R10×W0[1,0,0] + ...                            // 第二行
             + ...
             // 共 27 项乘法

```

## NHWC vs NCHW 在 Im2Col 中的差异