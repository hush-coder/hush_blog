# 切分策略

## 策略1：PartitionOpsIntoFunc - 基于Anchor算子切分

### 切分策略：

- 识别Anchor Op：遍历main函数，标记所有计算密集型算子
- 以Anchor为核心创建Subnet：每个anchor op单独或与邻近op组成一个subnet
- 创建func.func：为每个subnet生成独立的函数

### 示意图：

```
main函数 (flat structure, 1000+ ops)
    ↓ 识别anchor ops
┌─────────────────────────────────┐
│ Op1 (Cast)                      │ ← 普通op
│ Op2 (Reshape)                   │ ← 普通op
│ Op3 (Conv) ⭐ Anchor            │ ← Subnet 1
│ Op4 (BatchNorm)                 │ ← 合并到Subnet 1
│ Op5 (ReLU) ⭐ Anchor            │ ← Subnet 1
│ Op6 (Add)                       │ ← 普通op
│ Op7 (MatMul) ⭐ Anchor          │ ← Subnet 2
│ ...                             │
└─────────────────────────────────┘
         ↓ 切分为
┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
│ Subnet_0         │  │ Subnet_1         │  │ Subnet_2         │
│ - Op1, Op2       │  │ - Op3, Op4, Op5  │  │ - Op7            │
│ (Reshape, Cast)  │  │ (Conv+BN+ReLU)   │  │ (MatMul)         │
└──────────────────┘  └──────────────────┘  └──────────────────┘
```

### 权衡

- ✅ 优点：按计算密集型操作分割，每个subnet有明确的计算核心
- ✅ 优点：便于硬件映射（Conv→CVU, Reduce→VRAC）
- ❌ 缺点：可能产生大量细粒度subnet
- ❌ 缺点：轻量级操作（Reshape, Transpose）也会被分割出来

## 策略2：PartitionGraphForCalls - 基于func.call边界切分

### 切分策略：

1. 识别所有func.call - 这些是已经提取的子图（可能是手写kernel）
2. 以call为"break edge" - 将计算图切分为独立的subnet
3. 处理循环依赖 - 检测并打破循环，保证DAG（有向无环图）
4. 处理bypass paths - 处理跨越custom op的数据流路径

### 示意图：

```
Before:
main() {
  %0 = Conv(...)
  %1 = call @msda_v2_0(...)  ← break edge 1
  %2 = Add(...)
  %3 = call @vit_attn_0(...) ← break edge 2
  %4 = Mul(...)
}

After:
Subnet 0: {Conv}
Subnet 1: {@msda_v2_0} (独立的手写kernel)
Subnet 2: {Add}
Subnet 3: {@vit_attn_0} (独立的手写kernel)
Subnet 4: {Mul}
```

### 权衡：

- ✅ 优点：复杂模式用手写kernel，性能最优
- ✅ 优点：白名单机制保证质量（只有验证过的pattern才用手写实现）
- ❌ 缺点：需要人工维护白名单和手写代码
- ❌ 缺点：非白名单pattern会被inline回去，增加编译时间

# 切分权衡

## 粒度权衡

### 细粒度分割（O0模式）

```
Conv → [Subnet1] → Reshape → [Subnet2] → Add → [Subnet3] → ...
```
- **优点**：便于调试，每个subnet对应清晰的操作
- **缺点**：大量subnet边界 → 数据传输开销 ↑
- **缺点**：调度复杂度 ↑

### 粗粒度融合（优化模式）

```
Conv + Reshape + Add → [FusedSubnet1] → ...
```

- **优点**：减少数据传输（中间结果留在local memory）
- **优点**：减少kernel launch开销
- **缺点**：难以跨subnet并行
- **缺点**：融合过度会导致单个kernel过大（寄存器溢出、编译时间↑）

## 内存与通信权衡

***Subnet边界的代价***

每次跨subnet需要：

1. 数据序列化 (--subnet-serialization)
2. 同步点插入 (--insert-sync-joints)
3. 内存拷贝 (可能需要从local→global→local)

从配置可以看到：

```
--insert-sync-joints          # 在subnet边界插入同步
--vsv-coalescing              # 合并同步变量
--sv-allocation               # 分配同步变量
```

***权衡：***

- **少量大subnet**：同步少，但并行度低
- **大量小subnet**：同步多，但并行度高

