***Infinitensor-C++基础篇（2）***

## 摘要

本篇博客继续深入探讨 C++ 基础知识，重点讲解了 union、variant 及其访问方式 visit，详细介绍了 Lambda 表达式的定义、语法、捕获方式、作为参数传递的用法，以及 std::function 的定义和应用。通过丰富的代码示例，帮助读者理解现代 C++ 中函数式编程相关的核心概念和实际用法。

## 目录

- [AI编译器-C++基础篇（2）](#ai编译器-c基础篇2)
  - [摘要](#摘要)
  - [目录](#目录)
  - [前言](#前言)
  - [知识点](#知识点)
    - [union](#union)
      - [variant](#variant)
        - [visit](#visit)
    - [Lambda](#lambda)
      - [定义](#定义)
      - [基本语法](#基本语法)
      - [几个例子](#几个例子)
      - [捕获](#捕获)
      - [参数传递](#参数传递)
      - [类型](#类型)
      - [可变状态mutable](#可变状态mutable)
    - [std::function](#stdfunction)
      - [例子](#例子)
      - [作为参数传递](#作为参数传递)
      - [注意](#注意)

## 前言

本人正在搞AI编译器，这个博客大家可以当作学习笔记

接上回，继续对于variant的visit的研究

## 知识点

### union

#### variant

##### visit

访问当前存储的值，visitor 是一个可调用对象（如 lambda），会自动匹配当前类型。

> **可调用对象：** 指的是能像函数那样用（）调用的对象。
> 
> **Lambda表达式：** 等会单开一个

**基本形式：** 

```cpp
visit(visitor,variant);
```

---

### Lambda

#### 定义 

C++11 引入的一种“匿名函数”，也叫“闭包”，在代码中临时定义一个小函数，可以像变量一样传递、赋值、调用。

#### 基本语法

```cpp
[捕获列表](参数列表) -> 返回类型 { 函数体 }
```

- **捕获列表 []：** 决定 lambda 能否访问外部变量。
- **参数列表 ()：** 和普通函数一样
- **返回类型 ->：** 可以省略，编译器能推断时不用写。
- **函数体 {}：** 要执行的代码。

#### 几个例子

```cpp
auto f = []() { std::cout << "Hello, Lambda!" << std::endl; };

f(); // 输出 Hello, Lambda!
```

> 捕获列表为空
> 参数列表为空
> 返回类型省略

```cpp
auto add = [](int a, int b) { return a + b; };

int result = add(2, 3); // result = 5
```

> 捕获列表为空，参数返回值均不为空

#### 捕获

- **值捕获[=]:** [=] 表示“把外部所有变量都拷贝一份进来”。

```cpp
int x = 10;

auto printX = [=]() { std::cout << x << std::endl; };

printX(); // 输出 10
```

- **引用捕获[&]：** [&] 表示“用外部变量的引用”，可以修改外部变量。

```cpp
int x = 10;

auto changeX = [&]() { x = 20; };

changeX();

std::cout << x << std::endl; // 输出 20
```

- **指定捕获：** 

```cpp
int a = 1, b = 2;

auto f = [a, &b]() { /* a是值捕获，b是引用捕获 */ };
```

#### 参数传递

- **原因：** 可以把“行为”当作参数传递给函数，让函数变得更灵活。
- **语法和例子：** 

    ```cpp
    // 例一：算法库中的用法
    // 如for_each
    #include <vector>
    #include <algorithm>
    #include <iostream>

    int main() {
        std::vector<int> v = {1, 2, 3, 4, 5};
        std::for_each(v.begin(), v.end(), [](int n) {
        std::cout << n << " ";
    });

    // 输出：1 2 3 4 5
    }
    //这里的 [](int n) { ... } 就是 lambda，作为参数传递给 for_each。

    /*********************************/

    // 例二： 自定义函数接收 lambda
    #include <iostream>

    template<typename Func>
    void doTwice(Func f) {
        f();
        f();
    }

    int main() {
        doTwice([]() { std::cout << "Hello!" << std::endl; });
    // 输出两次 Hello!
    }
    // 注意：这里的doTwice接受任何可调用对象。

    /*********************************/

    // 例三：用 std::function 作为参数
    #include <functional>
    #include <iostream>

    void callWith42(const std::function<void(int)>& func) {
    func(42);
    }

    int main() {
        callWith42([](int x) { std::cout << "x = " << x << std::endl; });
        // 输出 x = 42
    }
    // 注意：std::function<void(int)>，可以接收任何“接收 int、返回 void”的可调用对象。
    ```

#### 类型

Lambda 是一种 **“匿名类”**，你不能直接写出它的类型，但可以用 **auto** 或 **std::function**：

```cpp
auto f = [](){ return 42; }; // 用auto自动推断

std::function<int()> g = [](){ return 42; }; // 用std::function
```

#### 可变状态mutable

默认情况下，值捕获的变量在 lambda 里是**只读**的。如果你想修改它们，需要加 **mutable**：

```cpp
int x = 10;

auto f = [x]() mutable { x = 20; std::cout << x << std::endl; };

f(); // 输出 20

std::cout << x << std::endl; // 还是 10，外部x没变
```

---

### std::function

- **定义：** C++11 引入的一个**通用函数封装器**，可以用来存储、传递、调用任何“可调用对象”。

```cpp
#include <functional>

std::function<返回类型(参数类型列表)> 变量名;
```

#### 例子

- 存储普通函数

```cpp
int add(int a, int b) { return a + b; }

std::function<int(int, int)> f = add;

std::cout << f(1, 2) << std::endl; // 输出 3
```

- 存储lambda

```cpp
std::function<void()> f = [](){ std::cout << "Hello" << std::endl; };

f(); // 输出 Hello
```

- 存储仿函数

```cpp
struct Functor {
    int operator()(int x) const { return x * x; }
};

std::function<int(int)> f = Functor();

std::cout << f(5) << std::endl; // 输出 25
```

#### 作为参数传递

可以用 std::function 作为**函数参数类型**，让你的函数能接收任意可调用对象：

```cpp
void runTwice(const std::function<void()>& func) {
    func();
    func();
}

runTwice([](){ std::cout << "Hi" << std::endl; });
// 输出两次 Hi
```

#### 注意

- **类型安全：**只有签名匹配的可调用对象才能赋值给 std::function。
- **性能：** std::function 有一定的运行时开销（比直接用模板略慢），但一般可以接受。
- **与模板：** 若只需要临时传递 lambda，且不需要存储，优先用模板（如 auto 或 template<typename F>），效率更高。

