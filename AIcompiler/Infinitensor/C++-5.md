***Infinitensor-C++基础篇（5）***

## 摘要

## 目录

## 前言

本人正在搞AI编译器，这个博客大家可以当作学习笔记

## 知识点

### const修饰成员函数

```cpp
size_t get(int i) {
        for (; cached <= i; ++cached) {
            if(cached == 0) cache[cached] = 0;
            else if(cached == 1) cache[cached] = 1;
            else{
                cache[cached] = cache[cached - 1] + cache[cached - 2];
            }   
        }
        return cache[i];
    }

    // NOTICE: 不要修改这个方法
    // NOTICE: 名字相同参数也相同，但 const 修饰不同的方法是一对重载方法，可以同时存在
    //         本质上，方法是隐藏了 this 参数的函数
    //         const 修饰作用在 this 上，因此它们实际上参数不同
    size_t get(int i) const {
        if (i <= cached) {
            return cache[i];
        }
        ASSERT(false, "i out of range");
    }
```

> 非const对象调用非const版本
>
> const对象调用const版本

### 移动构造器

#### 核心思想

***"移动"资源而不是复制资源，通常用于提高性能。***

#### 注意事项

- noexcept 关键字

```cpp
class Example {
public:
    // 移动构造器应该标记为 noexcept
    Example(Example&& other) noexcept {
        // 移动操作
    }
};

// 原因：标准库容器需要知道移动操作是否可能抛出异常
std::vector<Example> vec;
vec.push_back(Example());  // 如果移动构造器可能抛出异常，vector会使用拷贝
```

- 自移动问题

```cpp
class Example {
public:
    Example& operator=(Example&& other) noexcept {
        if (this != &other) {  // 防止自移动
            // 移动操作
        }
        return *this;
    }
};

// 使用
Example obj;
obj = std::move(obj);  // 自移动，需要检查
```

- 资源状态

```cpp
class Example {
    int* data;
public:
    Example(Example&& other) noexcept {
        data = other.data;
        other.data = nullptr;  // 重要：将源对象置空
    }
    
    ~Example() {
        delete data;  // 安全：nullptr可以被delete
    }
};
```

#### 优势

- **性能优势：**O(1) 时间复杂度，避免深拷贝(O(n))。
- **资源转移：**转移资源所有权，而不是复制。
- **源对象置空：**移动后源对象处于有效但未定义状态。

### 左值与右值

#### 基本概念

***左值（lvalue）***

- **定义**：可以取地址的表达式
- **特点**：有持久的内存位置
- **用途**：可以出现在赋值语句的左边

***右值（rvalue）***

- **定义**：不能取地址的表达式
- **特点**：临时值，没有持久的内存位置
- **用途**：只能出现在赋值语句的右边

***左值引用***

```cpp
int x = 42;
int& ref = x;      // 左值引用，绑定到左值

// 错误：不能绑定到右值
// int& ref2 = 42;  // 编译错误！

// 例外：const 左值引用可以绑定到右值
const int& cref = 42;  // 正确
```

***右值引用***

```cpp
int x = 42;
int&& rref = 42;   // 右值引用，绑定到右值
int&& rref2 = x + 1;  // 绑定到表达式结果

// 错误：不能绑定到左值
// int&& rref3 = x;  // 编译错误！

// 使用 std::move 将左值转换为右值
int&& rref4 = std::move(x);  // 正确
```

#### 移动语义

```cpp
class String {
    char* data;
public:
    // 拷贝构造函数（处理左值）
    String(const String& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }
    
    // 移动构造函数（处理右值）
    String(String&& other) noexcept {
        data = other.data;        // 转移资源
        other.data = nullptr;     // 源对象置空
    }
};

// 使用
String s1("hello");
String s2 = s1;        // 拷贝构造
String s3 = String("world");  // 移动构造
```

#### 完美转发

```cpp
template<typename T>
void wrapper(T&& arg) {
    // 完美转发
    process(std::forward<T>(arg));
}

void process(int& value) {
    std::cout << "lvalue" << std::endl;
}

void process(int&& value) {
    std::cout << "rvalue" << std::endl;
}

// 使用
int x = 42;
wrapper(x);        // 转发左值
wrapper(42);       // 转发右值
```
> **T&&** 在模板参数推导下称为**转发引用** 或**万能引用** 。
> 
> **std::forward<T>(arg)** 保留了arg的左值/右值属性。

