***Infinitensor-C++基础篇（4）***

## 摘要

本文深入探讨了C++中const和constexpr的详细用法、类构造器的各种形式、RAII原则、内存管理以及智能指针的完整指南。重点介绍了浅拷贝与深拷贝的区别、实现方式以及最佳实践，包括现代C++中智能指针的使用方法。通过大量实际代码示例，详细讲解了拷贝构造函数的正确实现、内存安全的重要性，以及如何避免常见的编程陷阱如双重释放和内存泄漏。文章还涵盖了三/五法则、移动语义等现代C++的重要概念，为读者提供了完整的C++对象生命周期管理指南。

**关键词：** C++、const、constexpr、构造函数、RAII、智能指针、浅拷贝、深拷贝、内存管理

## 目录

- [AI编译器-C++基础篇（4）](#ai编译器-c基础篇4)
  - [摘要](#摘要)
  - [目录](#目录)
  - [前言](#前言)
  - [知识点](#知识点)
    - [const和constexpr](#const和constexpr)
      - [与static的结合](#与static的结合)
      - [const static与constexpr static](#const-static与constexpr-static)
    - [class与struct](#class与struct)
    - [class的初始器](#class的初始器)
      - [默认构造器](#默认构造器)
      - [带参数的构造器](#带参数的构造器)
      - [拷贝构造器](#拷贝构造器)
      - [移动构造器](#移动构造器)
      - [初始化列表](#初始化列表)
      - [委托构造器（C++11）](#委托构造器c11)
      - [explicit 关键字](#explicit-关键字)
      - [constexpr 构造器](#constexpr-构造器)
    - [RAII原则](#raii原则)
    - [new和delete](#new和delete)
      - [new](#new)
      - [delete](#delete)
    - [智能指针](#智能指针)
      - [为什么需要智能指针](#为什么需要智能指针)
      - [std::unique\_ptr](#stdunique_ptr)
      - [std::shared\_ptr](#stdshared_ptr)
      - [std::weak\_ptr](#stdweak_ptr)
      - [智能指针的最佳实践](#智能指针的最佳实践)
      - [实际应用场景](#实际应用场景)
      - [性能考虑](#性能考虑)
      - [智能指针选择指南](#智能指针选择指南)
      - [关键原则](#关键原则)
    - [浅拷贝与深拷贝](#浅拷贝与深拷贝)
      - [浅拷贝](#浅拷贝)
      - [深拷贝](#深拷贝)
      - [浅拷贝的实现方式](#浅拷贝的实现方式)
      - [深拷贝的实现方式](#深拷贝的实现方式)
      - [不同数据类型的拷贝方式](#不同数据类型的拷贝方式)
      - [现代C++的拷贝方式](#现代c的拷贝方式)
      - [拷贝方式的选择](#拷贝方式的选择)
      - [最佳实践](#最佳实践)
      - [总结](#总结)

## 前言

本人正在搞AI编译器，这个博客大家可以当作学习笔记

## 知识点

### const和constexpr

***constexpr 对象自动是 const***

- 何时用**constexpr**？
  1. 编译时就需要确定的值。
  2. 用作模板的非类型参数
  3. 定义数组大小
  4. 避免运行时计算
- 何时使用 **const**？
  1. 值在运行时才能确定。
  2. 只需要防止修改

#### 与static的结合

- 单独用static时：

```cpp
class Counter {
public:
    static int count;  // 静态成员变量
    static void increment() { count++; }  // 静态成员函数
};

int Counter::count = 0;  // 外部定义

// 使用
Counter::count = 10;
Counter::increment();
```
> 需要外部定义并且可被更改，不过会保留更改，是类的变量而非对象

#### const static与constexpr static

- 前者仍需定义，不定义的话可用其值，但会没有内存地址分配而不能使用指针
- 后者无需定义，声明即为定义，但也无法取地址
> 前者可以通过static const inline解决

| 特性 | static | const | constexpr | static const | constexpr static |
|------|--------|-------|-----------|--------------|------------------|
| 存储方式 | 静态存储 | 成员存储 | 编译时内联 | 静态存储 | 编译时内联 |
| 初始化时机 | 程序启动 | 对象构造 | 编译时 | 编译时/运行时 | 编译时 |
| 是否需要外部定义 | ✅ | ❌ | ❌ | ✅ | ❌ |
| 可以取地址 | ✅ | ✅ | ❌ | ✅ | ❌ |
| 可以用于模板参数 | ❌ | ❌ | ✅ | ❌ | ✅ |
| 零运行时开销 | ❌ | ❌ | ✅ | ❌ | ✅ |
| 线程安全 | ❌ | ✅ | ✅ | ✅ | ✅ |
| 可以修改 | ✅ | ❌ | ❌ | ❌ | ❌ |
| 编译时确定 | ❌ | ❌ | ✅ | 部分 | ✅ |
| 内存占用 | 有 | 有 | 无 | 有 | 无 |

### class与struct

***唯一区别就是，`class` 默认访问控制符是 `private`，`struct` 默认访问控制符是 `public`。***

### class的初始器

#### 默认构造器

```cpp
class Point {
    int x, y;
public:
    // 默认构造器
    Point() : x(0), y(0) { }
    
    // 或者让编译器生成
    Point() = default;
    
    // 或者删除默认构造器
    Point() = delete;
};
```

#### 带参数的构造器

```cpp
class Rectangle {
    int width, height;
public:
    // 带参数的构造器
    Rectangle(int w, int h) : width(w), height(h) { }
    
    // 多个重载版本
    Rectangle(int size) : width(size), height(size) { }
};
```

#### 拷贝构造器

```cpp
class String {
    char* data;
public:
    // 拷贝构造器
    String(const String& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }
    
    // 或者让编译器生成
    String(const String&) = default;
    
    // 或者删除拷贝构造器
    String(const String&) = delete;
};
```

#### 移动构造器

```cpp
class Vector {
    int* data;
    size_t size;
public:
    // 移动构造器
    Vector(Vector&& other) noexcept 
        : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }
};
```

#### 初始化列表

```cpp
class Complex {
    double real, imag;
public:
    // 推荐：使用初始化列表
    Complex(double r, double i) : real(r), imag(i) { }
    
    // 不推荐：在函数体内赋值
    Complex(double r, double i) {
        real = r;  // 先默认构造，再赋值
        imag = i;
    }
};
```
> 注意：数组的初始化是cache{},变量是cached()。

#### 委托构造器（C++11）

```cpp
class Time {
    int hour, minute, second;
public:
    // 主构造器
    Time(int h, int m, int s) : hour(h), minute(m), second(s) { }
    
    // 委托给主构造器
    Time() : Time(0, 0, 0) { }
    Time(int h) : Time(h, 0, 0) { }
    Time(int h, int m) : Time(h, m, 0) { }
};
```

#### explicit 关键字

```cpp
class Array {
    int* data;
    size_t size;
public:
    // 防止隐式转换
    explicit Array(size_t s) : size(s) {
        data = new int[size];
    }
};

// 使用
Array arr(10);     // OK
// Array arr = 10;  // 编译错误！explicit阻止隐式转换
```
> 仅针对单参数构造，多参数无需

#### constexpr 构造器

```cpp
class Point {
    int x, y;
public:
    // 编译时构造器
    constexpr Point(int x, int y) : x(x), y(y) { }
    constexpr int getX() const { return x; }
    constexpr int getY() const { return y; }
};

constexpr Point p(10, 20);  // 编译时常量对象
```

### RAII原则

RAII是C++中资源管理的核心原则，意思是"**资源获取即初始化**"。

```cpp
class ResourceManager {
    Resource* resource;
public:
    // 构造函数：获取资源
    ResourceManager() : resource(acquire_resource()) { }
    
    // 析构函数：释放资源
    ~ResourceManager() { 
        release_resource(resource); 
    }
};
```

### new和delete

#### new

```cpp
// 分配单个对象
int* ptr = new int;           // 默认初始化
int* ptr2 = new int(42);      // 值初始化
int* ptr3 = new int{42};      // 列表初始化

// 分配数组
int* arr = new int[10];       // 默认初始化
int* arr2 = new int[10]();    // 值初始化
int* arr3 = new int[10]{1,2,3,4,5};  // 列表初始化
```

- **异常处理：**

```cpp
// new 可能抛出 std::bad_alloc
try {
    int* ptr = new int[1000000000];  // 可能失败
} catch (const std::bad_alloc& e) {
    std::cerr << "内存分配失败: " << e.what() << std::endl;
}
```

- **不抛出的new：**

```cpp
// new (nothrow) 不抛出异常，失败时返回 nullptr
int* ptr = new (std::nothrow) int[1000000];
if (!ptr) {
    std::cerr << "内存分配失败" << std::endl;
}
```

#### delete

```cpp
// 释放单个对象
int* ptr = new int(42);
delete ptr;  // 释放内存
ptr = nullptr;  // 防止悬空指针

// 释放数组
int* arr = new int[10];
delete[] arr;  // 使用 delete[] 释放数组
arr = nullptr;
```

### 智能指针

智能指针是C++11引入的RAII类模板，用于自动管理动态分配的内存，防止内存泄漏。

#### 为什么需要智能指针

```cpp
// 传统方式的问题
void bad_function() {
    int* ptr = new int(42);
    // 如果这里抛出异常或提前返回，内存泄漏！
    throw std::runtime_error("Error");
    delete ptr;  // 永远不会执行
}

// 智能指针方式
void good_function() {
    std::unique_ptr<int> ptr(new int(42));
    // 即使抛出异常，内存也会自动释放
    throw std::runtime_error("Error");
    // 析构函数自动调用，内存自动释放
}
```

#### std::unique_ptr

1. **基本用法：**
```cpp
#include <memory>

// 创建 unique_ptr
std::unique_ptr<int> ptr1(new int(42));
std::unique_ptr<int> ptr2 = std::make_unique<int>(42);  // C++14，推荐

// 使用
*ptr1 = 100;
int value = *ptr1;

// 检查是否为空
if (ptr1) {
    std::cout << "ptr1 is not null" << std::endl;
}
```

2. **所有权语义：**

```cpp
class Resource {
public:
    Resource() { std::cout << "Resource created" << std::endl; }
    ~Resource() { std::cout << "Resource destroyed" << std::endl; }
};

// unique_ptr 独占所有权
std::unique_ptr<Resource> ptr1 = std::make_unique<Resource>();
// std::unique_ptr<Resource> ptr2 = ptr1;  // 编译错误！不能拷贝

// 转移所有权
std::unique_ptr<Resource> ptr2 = std::move(ptr1);  // ptr1 变为 nullptr
```

3. **数组管理：**

```cpp
// 管理数组
std::unique_ptr<int[]> arr = std::make_unique<int[]>(10);
arr[0] = 42;
arr[1] = 100;

// 自定义删除器
auto deleter = [](int* ptr) {
    std::cout << "Custom deleter called" << std::endl;
    delete[] ptr;
};
std::unique_ptr<int, decltype(deleter)> custom_ptr(new int[10], deleter);
```

#### std::shared_ptr

1. **基本用法：**

```cpp
#include <memory>

// 创建 shared_ptr
std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
std::shared_ptr<int> ptr2 = ptr1;  // 共享所有权

// 引用计数
std::cout << "Reference count: " << ptr1.use_count() << std::endl;  // 2

// 使用
*ptr1 = 100;
int value = *ptr2;  // 100，共享同一个对象
```

2. **引用计数：**

```cpp
class Example {
public:
    Example() { std::cout << "Example created" << std::endl; }
    ~Example() { std::cout << "Example destroyed" << std::endl; }
};

void function() {
    std::shared_ptr<Example> ptr1 = std::make_shared<Example>();
    {
        std::shared_ptr<Example> ptr2 = ptr1;  // 引用计数：2
        std::cout << "Reference count: " << ptr1.use_count() << std::endl;
    }  // ptr2 销毁，引用计数：1
    std::cout << "Reference count: " << ptr1.use_count() << std::endl;
}  // ptr1 销毁，引用计数：0，对象被销毁
```

3. **循环引用问题：**

```cpp
struct Node {
    std::shared_ptr<Node> next;
    std::shared_ptr<Node> prev;
    
    ~Node() { std::cout << "Node destroyed" << std::endl; }
};

// 循环引用导致内存泄漏
std::shared_ptr<Node> node1 = std::make_shared<Node>();
std::shared_ptr<Node> node2 = std::make_shared<Node>();
node1->next = node2;
node2->prev = node1;  // 循环引用！
```

4. **解决循环引用：**

```cpp
struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;  // 使用 weak_ptr 避免循环引用
    
    ~Node() { std::cout << "Node destroyed" << std::endl; }
};

std::shared_ptr<Node> node1 = std::make_shared<Node>();
std::shared_ptr<Node> node2 = std::make_shared<Node>();
node1->next = node2;
node2->prev = node1;  // 不会造成循环引用
```

#### std::weak_ptr

1. **基本用法：**

```cpp
std::shared_ptr<int> shared = std::make_shared<int>(42);
std::weak_ptr<int> weak = shared;  // 创建 weak_ptr

// 检查对象是否还存在
if (auto locked = weak.lock()) {
    std::cout << "Object still exists: " << *locked << std::endl;
} else {
    std::cout << "Object has been destroyed" << std::endl;
}
```

**观察者模式：**

```cpp
class Subject {
    std::vector<std::weak_ptr<class Observer>> observers;
public:
    void addObserver(std::weak_ptr<class Observer> obs) {
        observers.push_back(obs);
    }
    
    void notify() {
        // 清理已销毁的观察者
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [](const std::weak_ptr<class Observer>& obs) {
                    return obs.expired();
                }),
            observers.end()
        );
        
        // 通知剩余的观察者
        for (auto& obs : observers) {
            if (auto locked = obs.lock()) {
                locked->update();
            }
        }
    }
};
```

#### 智能指针的最佳实践

**优先使用 make_ 函数：**

```cpp
// 推荐
auto ptr1 = std::make_unique<int>(42);
auto ptr2 = std::make_shared<int>(42);

// 不推荐
std::unique_ptr<int> ptr1(new int(42));
std::shared_ptr<int> ptr2(new int(42));
```

**避免裸指针：**

```cpp
// 不推荐
int* raw_ptr = new int(42);
std::unique_ptr<int> smart_ptr(raw_ptr);  // 危险！

// 推荐
auto smart_ptr = std::make_unique<int>(42);
```

**正确传递智能指针：**

```cpp
// 函数参数
void function(std::unique_ptr<int> ptr);  // 转移所有权
void function(const std::shared_ptr<int>& ptr);  // 共享，不转移所有权
void function(const std::weak_ptr<int>& ptr);  // 观察，不转移所有权

// 返回值
std::unique_ptr<int> create_unique() {
    return std::make_unique<int>(42);
}

std::shared_ptr<int> create_shared() {
    return std::make_shared<int>(42);
}
```

#### 实际应用场景

**资源管理：**

```cpp
class FileHandler {
    std::unique_ptr<FILE, decltype(&fclose)> file;
public:
    FileHandler(const char* filename) 
        : file(fopen(filename, "r"), fclose) {
        if (!file) throw std::runtime_error("Cannot open file");
    }
    
    // 不需要析构函数！
    void read() {
        // 读取文件
    }
};
```

**工厂模式：**

```cpp
class Widget {
public:
    virtual ~Widget() = default;
    virtual void draw() = 0;
};

class Button : public Widget {
public:
    void draw() override { std::cout << "Drawing button" << std::endl; }
};

class TextBox : public Widget {
public:
    void draw() override { std::cout << "Drawing textbox" << std::endl; }
};

std::unique_ptr<Widget> createWidget(const std::string& type) {
    if (type == "button") return std::make_unique<Button>();
    if (type == "textbox") return std::make_unique<TextBox>();
    return nullptr;
}
```

**缓存系统：**

```cpp
class Cache {
    std::unordered_map<std::string, std::weak_ptr<Resource>> cache;
public:
    std::shared_ptr<Resource> get(const std::string& key) {
        auto it = cache.find(key);
        if (it != cache.end()) {
            if (auto resource = it->second.lock()) {
                return resource;  // 资源还存在
            }
            cache.erase(it);  // 资源已被销毁
        }
        
        // 创建新资源
        auto resource = std::make_shared<Resource>();
        cache[key] = resource;
        return resource;
    }
};
```

#### 性能考虑

**内存开销：**

```cpp
// unique_ptr：几乎无开销
std::unique_ptr<int> ptr = std::make_unique<int>(42);
// 大小：通常等于裸指针大小

// shared_ptr：有引用计数开销
std::shared_ptr<int> ptr = std::make_shared<int>(42);
// 大小：通常是指针大小的两倍（包含引用计数）
```

**原子操作：**

```cpp
// shared_ptr 的引用计数操作是原子的
std::shared_ptr<int> ptr1 = std::make_shared<int>(42);
std::shared_ptr<int> ptr2 = ptr1;  // 原子操作
```

#### 智能指针选择指南

| 场景 | 推荐使用 | 原因 |
|------|----------|------|
| 独占所有权 | `std::unique_ptr` | 零开销，明确语义 |
| 共享所有权 | `std::shared_ptr` | 自动引用计数 |
| 观察对象 | `std::weak_ptr` | 避免循环引用 |
| 数组管理 | `std::unique_ptr<T[]>` | 自动调用 delete[] |

#### 关键原则

1. **优先使用智能指针**：避免手动内存管理
2. **使用 make_ 函数**：异常安全，性能更好
3. **避免循环引用**：使用 weak_ptr 观察 shared_ptr
4. **明确所有权语义**：unique_ptr 独占，shared_ptr 共享
5. **考虑性能影响**：unique_ptr 无开销，shared_ptr 有引用计数开销

### 浅拷贝与深拷贝

#### 浅拷贝

- **定义：** 浅拷贝只复制对象的成员变量值，对于指针成员，只复制指针地址，不复制指针指向的内容。
- **特点：**

```cpp
class ShallowCopy {
    int* data;
public:
    ShallowCopy(int value) : data(new int(value)) { }
    
    // 浅拷贝构造函数
    ShallowCopy(const ShallowCopy& other) {
        data = other.data;  // 只复制指针地址
    }
    
    ~ShallowCopy() { delete data; }
};
```

- **问题：**

```cpp
ShallowCopy obj1(42);
ShallowCopy obj2 = obj1;  // 浅拷贝

// 问题1：双重释放
// obj1 和 obj2 指向同一块内存
// obj1 析构时释放内存
// obj2 析构时再次释放同一块内存 → 程序崩溃

// 问题2：数据竞争
obj1.setValue(100);  // 修改数据
// obj2 的数据也被修改了，因为它们共享内存
```

#### 深拷贝

- **定义：** 深拷贝不仅复制对象的成员变量值，还复制指针指向的内容，为每个对象分配独立的内存。
- **实现方式：**

```cpp
class DeepCopy {
    int* data;
public:
    DeepCopy(int value) : data(new int(value)) { }
    
    // 深拷贝构造函数
    DeepCopy(const DeepCopy& other) {
        data = new int(*other.data);  // 复制指针指向的内容
    }
    
    ~DeepCopy() { delete data; }
};
```

#### 浅拷贝的实现方式

1. **编译器默认拷贝构造函数：**

```cpp
class AutoShallowCopy {
    int value;
    double* ptr;
public:
    AutoShallowCopy(int v, double* p) : value(v), ptr(p) { }
    
    // 编译器自动生成的拷贝构造函数（浅拷贝）
    // AutoShallowCopy(const AutoShallowCopy& other) : value(other.value), ptr(other.ptr) { }
};
```

2. **手动实现浅拷贝：**

```cpp
class ManualShallowCopy {
    int* data;
public:
    ManualShallowCopy(int value) : data(new int(value)) { }
    
    // 手动实现浅拷贝
    ManualShallowCopy(const ManualShallowCopy& other) {
        data = other.data;  // 只复制指针
    }
    
    ~ManualShallowCopy() { delete data; }
};
```

3. **使用赋值操作符：**

```cpp
class ShallowAssignment {
    int* data;
public:
    ShallowAssignment& operator=(const ShallowAssignment& other) {
        if (this != &other) {
            data = other.data;  // 浅拷贝
        }
        return *this;
    }
};
```

#### 深拷贝的实现方式

1. **手动实现深拷贝：**

```cpp
class ManualDeepCopy {
    int* data;
    size_t size;
public:
    ManualDeepCopy(size_t s) : data(new int[s]), size(s) { }
    
    // 手动实现深拷贝
    ManualDeepCopy(const ManualDeepCopy& other) {
        size = other.size;
        data = new int[size];
        
        // 复制数据
        for (size_t i = 0; i < size; ++i) {
            data[i] = other.data[i];
        }
    }
    
    ~ManualDeepCopy() { delete[] data; }
};
```

2. **使用标准库函数：**

```cpp
#include <algorithm>

class StdDeepCopy {
    int* data;
    size_t size;
public:
    StdDeepCopy(const StdDeepCopy& other) {
        size = other.size;
        data = new int[size];
        
        // 使用 std::copy
        std::copy(other.data, other.data + size, data);
    }
};
```

3. **使用 std::memcpy：**

```cpp
#include <cstring>

class MemcpyDeepCopy {
    int* data;
    size_t size;
public:
    MemcpyDeepCopy(const MemcpyDeepCopy& other) {
        size = other.size;
        data = new int[size];
        
        // 使用 memcpy（适用于POD类型）
        std::memcpy(data, other.data, size * sizeof(int));
    }
};
```

#### 不同数据类型的拷贝方式

1. **基本类型：**

```cpp
class BasicTypes {
    int value;
    double d;
    char c;
public:
    // 基本类型默认就是深拷贝
    BasicTypes(const BasicTypes& other) 
        : value(other.value), d(other.d), c(other.c) { }
};
```

2. **指针类型：**

```cpp
class PointerTypes {
    int* ptr;
    char* str;
public:
    // 指针需要手动深拷贝
    PointerTypes(const PointerTypes& other) {
        ptr = new int(*other.ptr);  // 深拷贝
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);  // 深拷贝字符串
    }
};
```

3. **数组类型：**

```cpp
class ArrayTypes {
    int* array;
    size_t size;
public:
    ArrayTypes(const ArrayTypes& other) {
        size = other.size;
        array = new int[size];
        std::copy(other.array, other.array + size, array);
    }
};
```

#### 现代C++的拷贝方式

1. **使用智能指针：**

```cpp
#include <memory>

class SmartPointerCopy {
    std::unique_ptr<int> data;
public:
    SmartPointerCopy(int value) : data(std::make_unique<int>(value)) { }
    
    // 智能指针自动处理拷贝
    SmartPointerCopy(const SmartPointerCopy& other) 
        : data(std::make_unique<int>(*other.data)) { }
};
```

2. **使用标准容器：**

```cpp
#include <vector>
#include <string>

class ContainerCopy {
    std::vector<int> data;
    std::string text;
public:
    // 标准容器自动深拷贝
    ContainerCopy(const ContainerCopy& other) 
        : data(other.data), text(other.text) { }
};
```

#### 拷贝方式的选择

1. **何时使用浅拷贝：**

```cpp
// 1. 只包含基本类型的类
class SimpleClass {
    int x, y;
public:
    // 编译器默认浅拷贝就足够了
};

// 2. 使用智能指针的类
class SmartClass {
    std::shared_ptr<int> data;
public:
    // shared_ptr 自动处理引用计数
};

// 3. 使用标准容器的类
class ContainerClass {
    std::vector<int> data;
public:
    // 标准容器自动深拷贝
};
```

2. **何时使用深拷贝：**

```cpp
// 1. 包含原始指针的类
class RawPointerClass {
    int* data;
public:
    // 必须手动实现深拷贝
    RawPointerClass(const RawPointerClass& other) {
        data = new int(*other.data);
    }
};

// 2. 管理资源的类
class ResourceClass {
    FILE* file;
public:
    // 需要深拷贝资源
    ResourceClass(const ResourceClass& other) {
        // 重新打开文件或复制文件内容
    }
};
```

#### 最佳实践

1. **三/五法则：**

```cpp
class RuleOfFive {
    int* data;
public:
    // 构造函数
    RuleOfFive(int value) : data(new int(value)) { }
    
    // 析构函数
    ~RuleOfFive() { delete data; }
    
    // 拷贝构造函数
    RuleOfFive(const RuleOfFive& other) {
        data = new int(*other.data);
    }
    
    // 拷贝赋值操作符
    RuleOfFive& operator=(const RuleOfFive& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
        }
        return *this;
    }
    
    // 移动构造函数
    RuleOfFive(RuleOfFive&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }
    
    // 移动赋值操作符
    RuleOfFive& operator=(RuleOfFive&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

2. **现代C++推荐：**

```cpp
// 推荐：使用智能指针和标准容器
class ModernClass {
    std::unique_ptr<int> data;
    std::vector<int> array;
    std::string text;
public:
    // 编译器自动生成正确的拷贝语义
};
```

#### 总结

| 特性 | 浅拷贝 | 深拷贝 |
|------|--------|--------|
| 内存共享 | ✅ 是 | ❌ 否 |
| 实现复杂度 | 简单 | 复杂 |
| 内存安全 | ❌ 不安全 | ✅ 安全 |
| 性能 | 快 | 较慢 |
| 适用场景 | 基本类型、智能指针 | 原始指针、资源管理 |

**关键原则：**
1. **优先使用智能指针**：避免手动内存管理
2. **使用标准容器**：自动处理拷贝语义
3. **遵循三/五法则**：如果需要析构函数，通常也需要拷贝操作
4. **明确所有权语义**：unique_ptr 独占，shared_ptr 共享

