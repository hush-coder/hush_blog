# AI编译器-C++基础篇（1）

## 目录

- [AI编译器-C++基础篇（1）](#ai编译器-c基础篇1)
  - [目录](#目录)
  - [前言](#前言)
  - [知识点](#知识点)
    - [ASSERT](#assert)
    - [static](#static)
    - [constexpr](#constexpr)
    - [arr](#arr)
    - [数据类型](#数据类型)
    - [纯函数](#纯函数)
      - [定义](#定义)
      - [作用](#作用)
    - [cache](#cache)
    - [enum和enum class](#enum和enum-class)
      - [传统enum](#传统enum)
      - [enum class](#enum-class)
    - [union](#union)
      - [类型双关](#类型双关)
      - [variant](#variant)
- [对于variant的visit的研究还没有结束，下篇继续](#对于variant的visit的研究还没有结束下篇继续)

---

## 前言

本人正在搞AI编译器，这个博客大家可以当作学习笔记

---

## 知识点

### ASSERT

```cpp
#define ASSERT(COND, MSG)                                                                         \
    if (!(COND)) {                                                                                \
        std::cerr << "\x1b[31mAssertion failed at line #" << __LINE__ << ": \x1b[0m" << std::endl \
                  << std::endl                                                                    \
                  << #COND << std::endl                                                           \
                  << std::endl                                                                    \
                  << "\x1b[34mMessage:\x1b[0m" << std::endl                                       \
                  << std::endl                                                                    \
                  << MSG << std::endl                                                             \
                  << std::endl;                                                                   \
        exit(1);                                                                                  \
    }
```

- 当COND为假时，程序会输出错误信息
- 有助于在调试或做题时快速发现和定位错误。
- 与断言（Assertion）类似

---

### static

- **若用于函数前：**
  1. 表示该函数的作用域仅限于本文件（即“内部链接”）。
  2. 只能在当前文件中被调用，不能被其他文件通过 extern 声明访问。
  3. 常用于只在本文件内部使用的工具函数。

- **若用于变量前:**
  1. 表示该变量在函数多次调用之间保持其值，而不是每次调用都重新创建。

---

### constexpr

```cpp
constexpr unsigned long long fibonacci(int i) {
    switch (i) {
        case 0:
            return 0;
        case 1:
            return 1;
        default:
            return fibonacci(i - 1) + fibonacci(i - 2);
    }
}
```

- **修饰函数的时候**，如果传入的参数是常量，编译器会在编译期间就计算出结果，而不是等到程序运行时才计算。
- **修饰变量的时候**，表示这个变量的值在编译期间就已经确定，是一个真正的常量。

> 计算量不能太大，超出了编译器的 constexpr 运算次数限制（默认 33554432 次）。
> 可以用-fconstexpr-ops-limit=100000000 ...来增加运算限制

---

### arr

- **sizeof()**函数计算的是字节数，即乘8之后的结果

---

### 数据类型

- **unsigned long long:** 无符号长长整型,通常为 8 字节（64 位）,不能表示负数。
- **long long:** 有符号长长整型，通常为 8 字节（64 位），能表示负数。
- **unsigned long:** 无符号长整型,通常为 4 或 8 字节（32 位或 64 位，取决于平台）,不能表示负数。
- **long:** 有符号长整型，通常为 4 或 8 字节，能表示负数。
- - **unsigned int:** 无符号整型,通常为 4 字节（32 位）,不能表示负数。
- **int:** 有符号整型，通常为 4 字节（32 位），能表示负数。
  
---

### 纯函数

#### 定义

- 相同输入必定相同输出，**无论何时调用**
- 纯函数**不会修改外部状态**（如全局变量、静态变量、输入参数、文件、数据库等）。
- 纯函数**不会依赖外部状态**（如全局变量、I/O、随机数等）。
- 纯函数不会产生可观察到的副作用（如打印输出、写文件、网络请求等）。

#### 作用

- 易于**测试**和**推理**：只需关注输入和输出。
- 易于**并行**和**缓存**：因为没有副作用，不会有竞态条件。
- 程序更健壮、可维护。

---

### cache

缓存数组，用于**存储已经计算过的数值**，避免重复计算。
> 可以提高运算效率。

---

### enum和enum class

#### 传统enum

```cpp
enum ColorEnum : unsigned char {
    COLOR_RED = 31,
    COLOR_GREEN,
    COLOR_YELLOW,
    COLOR_BLUE,
};
```

- 与C兼容
- 等价于constexpr常量
- 作用域：完全暴露在外部作用域，可以不需要前缀的引用。
- 类型安全：非强类型，可以隐式转化为其他类型
- 调用：

```cpp
ColorEnum c = COLOR_RED;
int n = COLOR_RED;
```

#### enum class

```cpp
enum class Color : int {
    Red = COLOR_RED,
    Green,
    Yellow,
    Blue,
};
```

- C++11之后支持
- 作用域：完枚举成员只在枚举类型作用域内可见，必须带前缀，用 Color::Red 这样访问。
- 类型安全：强类型，不同枚举类型不能混用。
- 调用：

```cpp
Color c = Color::Red;
```

---

### union

**定义：** 在同一内存位置存储的不同类型的值。

```cpp
union MyUnion {
    int i;
    float f;
    char c;
};

MyUnion u;
u.i = 42;      // 现在 u 里存的是 int
u.f = 3.14f;   // 现在 u 里存的是 float，原来的 int 值被覆盖
u.c = 'A';     // 现在 u 里存的是 char，原来的 float 值被覆盖
```

#### 类型双关

这里定义了一个union:

```cpp
union {
    int i;
    float f;
} u;
```

给其中的i赋值：

```cpp
u.i = 0x40490fdb;      // 以 int 形式写入
```

这时，可以一个整数的比特位“当作”浮点数来解释：

```cpp
float pi = u.f;        // 以 float 形式读取
return u.f;
```

如果不用union，也可以用指针强制转换，从而实现类型双关，但有未定义行为风险（C++ 标准不推荐）：

```cpp
int i = 0x40490fdb;
float f = *(float*)&i; // 把 int* 强转为 float*，再解引用
```

现代更推荐用**memcpy**做法，用 memcpy 进行字节级拷贝，避免未定义行为：

```cpp
int i = 0x40490fdb;
float f;
std::memcpy(&f, &i, sizeof(float));
```

#### variant

- **定义：**是 C++17 引入的标准库类型，用于安全地存储和操作多种类型中的某一种。

```cpp
#include <variant>
#include <iostream>

std::variant<int, float, std::string> v;

v = 42;           // 存储 int
v = 3.14f;        // 存储 float
v = "hello"s;     // 存储 std::string
```

- **访问：**

```cpp
// 方式一：std::get<T>
v = 42;
int i = std::get<int>(v); // 如果当前不是 int，会抛出 std::bad_variant_access

// 方式二：std::get_if<T>
std::variant<int, float, std::string> v = 42;
if (auto p = std::get_if<int>(&v)) {
    std::cout << "int: " << *p << std::endl;
} else {
    std::cout << "不是 int 类型" << std::endl;
}
// 如果当前不是类型 T，返回 nullptr，不会抛异常。

// 方式三：std::visit(visitor, variant)
std::variant<int, float, std::string> v = 3.14f;
std::visit([](auto&& arg){
    std::cout << arg << std::endl;
}, v); // 输出 3.14

```

---

# 对于variant的visit的研究还没有结束，下篇继续
